// Code generated by goa v3.21.1, DO NOT EDIT.
//
// profiles gRPC client encoders and decoders
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/profiles/design/api
// -o ./services/profiles/

package client

import (
	"context"

	profilespb "github.com/ynoacamino/infra-sustainable-classrooms/services/profiles/gen/grpc/profiles/pb"
	profiles "github.com/ynoacamino/infra-sustainable-classrooms/services/profiles/gen/profiles"
	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildGetCompleteProfileFunc builds the remote method to invoke for
// "profiles" service "GetCompleteProfile" endpoint.
func BuildGetCompleteProfileFunc(grpccli profilespb.ProfilesClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.GetCompleteProfile(ctx, reqpb.(*profilespb.GetCompleteProfileRequest), opts...)
		}
		return grpccli.GetCompleteProfile(ctx, &profilespb.GetCompleteProfileRequest{}, opts...)
	}
}

// EncodeGetCompleteProfileRequest encodes requests sent to profiles
// GetCompleteProfile endpoint.
func EncodeGetCompleteProfileRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*profiles.GetCompleteProfilePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("profiles", "GetCompleteProfile", "*profiles.GetCompleteProfilePayload", v)
	}
	return NewProtoGetCompleteProfileRequest(payload), nil
}

// DecodeGetCompleteProfileResponse decodes responses from the profiles
// GetCompleteProfile endpoint.
func DecodeGetCompleteProfileResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	message, ok := v.(*profilespb.GetCompleteProfileResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("profiles", "GetCompleteProfile", "*profilespb.GetCompleteProfileResponse", v)
	}
	res := NewGetCompleteProfileResult(message)
	return res, nil
}

// BuildGetPublicProfileByIDFunc builds the remote method to invoke for
// "profiles" service "GetPublicProfileById" endpoint.
func BuildGetPublicProfileByIDFunc(grpccli profilespb.ProfilesClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.GetPublicProfileByID(ctx, reqpb.(*profilespb.GetPublicProfileByIDRequest), opts...)
		}
		return grpccli.GetPublicProfileByID(ctx, &profilespb.GetPublicProfileByIDRequest{}, opts...)
	}
}

// EncodeGetPublicProfileByIDRequest encodes requests sent to profiles
// GetPublicProfileById endpoint.
func EncodeGetPublicProfileByIDRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*profiles.GetPublicProfileByIDPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("profiles", "GetPublicProfileById", "*profiles.GetPublicProfileByIDPayload", v)
	}
	return NewProtoGetPublicProfileByIDRequest(payload), nil
}

// DecodeGetPublicProfileByIDResponse decodes responses from the profiles
// GetPublicProfileById endpoint.
func DecodeGetPublicProfileByIDResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	message, ok := v.(*profilespb.GetPublicProfileByIDResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("profiles", "GetPublicProfileById", "*profilespb.GetPublicProfileByIDResponse", v)
	}
	res := NewGetPublicProfileByIDResult(message)
	return res, nil
}

// BuildValidateUserRoleFunc builds the remote method to invoke for "profiles"
// service "ValidateUserRole" endpoint.
func BuildValidateUserRoleFunc(grpccli profilespb.ProfilesClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.ValidateUserRole(ctx, reqpb.(*profilespb.ValidateUserRoleRequest), opts...)
		}
		return grpccli.ValidateUserRole(ctx, &profilespb.ValidateUserRoleRequest{}, opts...)
	}
}

// EncodeValidateUserRoleRequest encodes requests sent to profiles
// ValidateUserRole endpoint.
func EncodeValidateUserRoleRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*profiles.ValidateUserRolePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("profiles", "ValidateUserRole", "*profiles.ValidateUserRolePayload", v)
	}
	return NewProtoValidateUserRoleRequest(payload), nil
}

// DecodeValidateUserRoleResponse decodes responses from the profiles
// ValidateUserRole endpoint.
func DecodeValidateUserRoleResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	message, ok := v.(*profilespb.ValidateUserRoleResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("profiles", "ValidateUserRole", "*profilespb.ValidateUserRoleResponse", v)
	}
	res := NewValidateUserRoleResult(message)
	return res, nil
}
