// Code generated by goa v3.21.1, DO NOT EDIT.
//
// knowledge HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/knowledge/design/api
// -o ./services/knowledge/

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	knowledge "github.com/ynoacamino/infra-sustainable-classrooms/services/knowledge/gen/knowledge"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateTestPayload builds the payload for the knowledge CreateTest
// endpoint from CLI flags.
func BuildCreateTestPayload(knowledgeCreateTestBody string, knowledgeCreateTestSessionToken string) (*knowledge.CreateTestPayload, error) {
	var err error
	var body CreateTestRequestBody
	{
		err = json.Unmarshal([]byte(knowledgeCreateTestBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"title\": \"Quia eaque qui officia.\"\n   }'")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeCreateTestSessionToken
	}
	v := &knowledge.CreateTestPayload{
		Title: body.Title,
	}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetMyTestsPayload builds the payload for the knowledge GetMyTests
// endpoint from CLI flags.
func BuildGetMyTestsPayload(knowledgeGetMyTestsSessionToken string) (*knowledge.GetMyTestsPayload, error) {
	var sessionToken string
	{
		sessionToken = knowledgeGetMyTestsSessionToken
	}
	v := &knowledge.GetMyTestsPayload{}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetTestByIDPayload builds the payload for the knowledge GetTestById
// endpoint from CLI flags.
func BuildGetTestByIDPayload(knowledgeGetTestByIDTestID string, knowledgeGetTestByIDSessionToken string) (*knowledge.GetTestByIDPayload, error) {
	var err error
	var testID int64
	{
		testID, err = strconv.ParseInt(knowledgeGetTestByIDTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for testID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeGetTestByIDSessionToken
	}
	v := &knowledge.GetTestByIDPayload{}
	v.TestID = testID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildUpdateTestPayload builds the payload for the knowledge UpdateTest
// endpoint from CLI flags.
func BuildUpdateTestPayload(knowledgeUpdateTestBody string, knowledgeUpdateTestTestID string, knowledgeUpdateTestSessionToken string) (*knowledge.UpdateTestPayload, error) {
	var err error
	var body UpdateTestRequestBody
	{
		err = json.Unmarshal([]byte(knowledgeUpdateTestBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"title\": \"Tenetur id maiores debitis at aperiam reiciendis.\"\n   }'")
		}
	}
	var testID int64
	{
		testID, err = strconv.ParseInt(knowledgeUpdateTestTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for testID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeUpdateTestSessionToken
	}
	v := &knowledge.UpdateTestPayload{
		Title: body.Title,
	}
	v.TestID = testID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildDeleteTestPayload builds the payload for the knowledge DeleteTest
// endpoint from CLI flags.
func BuildDeleteTestPayload(knowledgeDeleteTestTestID string, knowledgeDeleteTestSessionToken string) (*knowledge.DeleteTestPayload, error) {
	var err error
	var testID int64
	{
		testID, err = strconv.ParseInt(knowledgeDeleteTestTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for testID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeDeleteTestSessionToken
	}
	v := &knowledge.DeleteTestPayload{}
	v.TestID = testID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetTestQuestionsPayload builds the payload for the knowledge
// GetTestQuestions endpoint from CLI flags.
func BuildGetTestQuestionsPayload(knowledgeGetTestQuestionsTestID string, knowledgeGetTestQuestionsSessionToken string) (*knowledge.GetTestQuestionsPayload, error) {
	var err error
	var testID int64
	{
		testID, err = strconv.ParseInt(knowledgeGetTestQuestionsTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for testID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeGetTestQuestionsSessionToken
	}
	v := &knowledge.GetTestQuestionsPayload{}
	v.TestID = testID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildAddQuestionPayload builds the payload for the knowledge AddQuestion
// endpoint from CLI flags.
func BuildAddQuestionPayload(knowledgeAddQuestionBody string, knowledgeAddQuestionTestID string, knowledgeAddQuestionSessionToken string) (*knowledge.AddQuestionPayload, error) {
	var err error
	var body AddQuestionRequestBody
	{
		err = json.Unmarshal([]byte(knowledgeAddQuestionBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"correct_answer\": 5237011504810502332,\n      \"option_a\": \"Dolores iusto sit fuga.\",\n      \"option_b\": \"Aliquam et totam aliquid aut optio.\",\n      \"option_c\": \"Libero quis sint.\",\n      \"option_d\": \"Magni nihil.\",\n      \"question_text\": \"Ducimus quia fugiat fuga molestiae accusantium amet.\"\n   }'")
		}
	}
	var testID int64
	{
		testID, err = strconv.ParseInt(knowledgeAddQuestionTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for testID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeAddQuestionSessionToken
	}
	v := &knowledge.AddQuestionPayload{
		QuestionText:  body.QuestionText,
		OptionA:       body.OptionA,
		OptionB:       body.OptionB,
		OptionC:       body.OptionC,
		OptionD:       body.OptionD,
		CorrectAnswer: body.CorrectAnswer,
	}
	v.TestID = testID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetQuestionByIDPayload builds the payload for the knowledge
// GetQuestionById endpoint from CLI flags.
func BuildGetQuestionByIDPayload(knowledgeGetQuestionByIDTestID string, knowledgeGetQuestionByIDQuestionID string, knowledgeGetQuestionByIDSessionToken string) (*knowledge.GetQuestionByIDPayload, error) {
	var err error
	var testID int64
	{
		testID, err = strconv.ParseInt(knowledgeGetQuestionByIDTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for testID, must be INT64")
		}
	}
	var questionID int64
	{
		questionID, err = strconv.ParseInt(knowledgeGetQuestionByIDQuestionID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for questionID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeGetQuestionByIDSessionToken
	}
	v := &knowledge.GetQuestionByIDPayload{}
	v.TestID = testID
	v.QuestionID = questionID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildUpdateQuestionPayload builds the payload for the knowledge
// UpdateQuestion endpoint from CLI flags.
func BuildUpdateQuestionPayload(knowledgeUpdateQuestionBody string, knowledgeUpdateQuestionTestID string, knowledgeUpdateQuestionQuestionID string, knowledgeUpdateQuestionSessionToken string) (*knowledge.UpdateQuestionPayload, error) {
	var err error
	var body UpdateQuestionRequestBody
	{
		err = json.Unmarshal([]byte(knowledgeUpdateQuestionBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"correct_answer\": 5497856277076629409,\n      \"option_a\": \"Sunt quidem vel enim.\",\n      \"option_b\": \"Ducimus deserunt fuga.\",\n      \"option_c\": \"Adipisci occaecati vel dolorum aut dolore.\",\n      \"option_d\": \"Fuga alias veniam.\",\n      \"question_text\": \"Et quis neque omnis enim et.\"\n   }'")
		}
	}
	var testID int64
	{
		testID, err = strconv.ParseInt(knowledgeUpdateQuestionTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for testID, must be INT64")
		}
	}
	var questionID int64
	{
		questionID, err = strconv.ParseInt(knowledgeUpdateQuestionQuestionID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for questionID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeUpdateQuestionSessionToken
	}
	v := &knowledge.UpdateQuestionPayload{
		QuestionText:  body.QuestionText,
		OptionA:       body.OptionA,
		OptionB:       body.OptionB,
		OptionC:       body.OptionC,
		OptionD:       body.OptionD,
		CorrectAnswer: body.CorrectAnswer,
	}
	v.TestID = testID
	v.QuestionID = questionID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildDeleteQuestionPayload builds the payload for the knowledge
// DeleteQuestion endpoint from CLI flags.
func BuildDeleteQuestionPayload(knowledgeDeleteQuestionTestID string, knowledgeDeleteQuestionQuestionID string, knowledgeDeleteQuestionSessionToken string) (*knowledge.DeleteQuestionPayload, error) {
	var err error
	var testID int64
	{
		testID, err = strconv.ParseInt(knowledgeDeleteQuestionTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for testID, must be INT64")
		}
	}
	var questionID int64
	{
		questionID, err = strconv.ParseInt(knowledgeDeleteQuestionQuestionID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for questionID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeDeleteQuestionSessionToken
	}
	v := &knowledge.DeleteQuestionPayload{}
	v.TestID = testID
	v.QuestionID = questionID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetAvailableTestsPayload builds the payload for the knowledge
// GetAvailableTests endpoint from CLI flags.
func BuildGetAvailableTestsPayload(knowledgeGetAvailableTestsSessionToken string) (*knowledge.GetAvailableTestsPayload, error) {
	var sessionToken string
	{
		sessionToken = knowledgeGetAvailableTestsSessionToken
	}
	v := &knowledge.GetAvailableTestsPayload{}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetTestFormPayload builds the payload for the knowledge GetTestForm
// endpoint from CLI flags.
func BuildGetTestFormPayload(knowledgeGetTestFormTestID string, knowledgeGetTestFormSessionToken string) (*knowledge.GetTestFormPayload, error) {
	var err error
	var testID int64
	{
		testID, err = strconv.ParseInt(knowledgeGetTestFormTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for testID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeGetTestFormSessionToken
	}
	v := &knowledge.GetTestFormPayload{}
	v.TestID = testID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildSubmitTestPayload builds the payload for the knowledge SubmitTest
// endpoint from CLI flags.
func BuildSubmitTestPayload(knowledgeSubmitTestBody string, knowledgeSubmitTestTestID string, knowledgeSubmitTestSessionToken string) (*knowledge.SubmitTestPayload, error) {
	var err error
	var body SubmitTestRequestBody
	{
		err = json.Unmarshal([]byte(knowledgeSubmitTestBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"answers\": [\n         {\n            \"question_id\": 4096248363570844082,\n            \"selected_answer\": 3700718689874649655\n         },\n         {\n            \"question_id\": 4096248363570844082,\n            \"selected_answer\": 3700718689874649655\n         },\n         {\n            \"question_id\": 4096248363570844082,\n            \"selected_answer\": 3700718689874649655\n         },\n         {\n            \"question_id\": 4096248363570844082,\n            \"selected_answer\": 3700718689874649655\n         }\n      ]\n   }'")
		}
		if body.Answers == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("answers", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var testID int64
	{
		testID, err = strconv.ParseInt(knowledgeSubmitTestTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for testID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeSubmitTestSessionToken
	}
	v := &knowledge.SubmitTestPayload{}
	if body.Answers != nil {
		v.Answers = make([]*knowledge.Answer, len(body.Answers))
		for i, val := range body.Answers {
			v.Answers[i] = marshalAnswerRequestBodyToKnowledgeAnswer(val)
		}
	} else {
		v.Answers = []*knowledge.Answer{}
	}
	v.TestID = testID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetMySubmissionsPayload builds the payload for the knowledge
// GetMySubmissions endpoint from CLI flags.
func BuildGetMySubmissionsPayload(knowledgeGetMySubmissionsSessionToken string) (*knowledge.GetMySubmissionsPayload, error) {
	var sessionToken string
	{
		sessionToken = knowledgeGetMySubmissionsSessionToken
	}
	v := &knowledge.GetMySubmissionsPayload{}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetSubmissionByIDPayload builds the payload for the knowledge
// GetSubmissionById endpoint from CLI flags.
func BuildGetSubmissionByIDPayload(knowledgeGetSubmissionByIDSubmissionID string, knowledgeGetSubmissionByIDSessionToken string) (*knowledge.GetSubmissionByIDPayload, error) {
	var err error
	var submissionID int64
	{
		submissionID, err = strconv.ParseInt(knowledgeGetSubmissionByIDSubmissionID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for submissionID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeGetSubmissionByIDSessionToken
	}
	v := &knowledge.GetSubmissionByIDPayload{}
	v.SubmissionID = submissionID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetSubmissionResultPayload builds the payload for the knowledge
// GetSubmissionResult endpoint from CLI flags.
func BuildGetSubmissionResultPayload(knowledgeGetSubmissionResultSubmissionID string, knowledgeGetSubmissionResultSessionToken string) (*knowledge.GetSubmissionResultPayload, error) {
	var err error
	var submissionID int64
	{
		submissionID, err = strconv.ParseInt(knowledgeGetSubmissionResultSubmissionID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for submissionID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = knowledgeGetSubmissionResultSessionToken
	}
	v := &knowledge.GetSubmissionResultPayload{}
	v.SubmissionID = submissionID
	v.SessionToken = sessionToken

	return v, nil
}
