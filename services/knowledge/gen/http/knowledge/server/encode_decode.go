// Code generated by goa v3.21.1, DO NOT EDIT.
//
// knowledge HTTP server encoders and decoders
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/knowledge/design/api
// -o ./services/knowledge/

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strconv"

	knowledge "github.com/ynoacamino/infra-sustainable-classrooms/services/knowledge/gen/knowledge"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeCreateTestResponse returns an encoder for responses returned by the
// knowledge CreateTest endpoint.
func EncodeCreateTestResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewCreateTestResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateTestRequest returns a decoder for requests sent to the knowledge
// CreateTest endpoint.
func DecodeCreateTestRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateTestRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateTestRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			sessionToken string
			c            *http.Cookie
		)
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateTestPayload(&body, sessionToken)

		return payload, nil
	}
}

// EncodeCreateTestError returns an encoder for errors returned by the
// CreateTest knowledge endpoint.
func EncodeCreateTestError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "invalid_input":
			var res knowledge.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetMyTestsResponse returns an encoder for responses returned by the
// knowledge GetMyTests endpoint.
func EncodeGetMyTestsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.TestsResponse)
		enc := encoder(ctx, w)
		body := NewGetMyTestsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetMyTestsRequest returns a decoder for requests sent to the knowledge
// GetMyTests endpoint.
func DecodeGetMyTestsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			sessionToken string
			err          error
			c            *http.Cookie
		)
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetMyTestsPayload(sessionToken)

		return payload, nil
	}
}

// EncodeGetMyTestsError returns an encoder for errors returned by the
// GetMyTests knowledge endpoint.
func EncodeGetMyTestsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetTestByIDResponse returns an encoder for responses returned by the
// knowledge GetTestById endpoint.
func EncodeGetTestByIDResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.TestResponse)
		enc := encoder(ctx, w)
		body := NewGetTestByIDResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetTestByIDRequest returns a decoder for requests sent to the
// knowledge GetTestById endpoint.
func DecodeGetTestByIDRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			testID       int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			testIDRaw := params["test_id"]
			v, err2 := strconv.ParseInt(testIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("test_id", testIDRaw, "integer"))
			}
			testID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetTestByIDPayload(testID, sessionToken)

		return payload, nil
	}
}

// EncodeGetTestByIDError returns an encoder for errors returned by the
// GetTestById knowledge endpoint.
func EncodeGetTestByIDError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "test_not_found":
			var res knowledge.TestNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateTestResponse returns an encoder for responses returned by the
// knowledge UpdateTest endpoint.
func EncodeUpdateTestResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewUpdateTestResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateTestRequest returns a decoder for requests sent to the knowledge
// UpdateTest endpoint.
func DecodeUpdateTestRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateTestRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateTestRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			testID       int64
			sessionToken string
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			testIDRaw := params["test_id"]
			v, err2 := strconv.ParseInt(testIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("test_id", testIDRaw, "integer"))
			}
			testID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateTestPayload(&body, testID, sessionToken)

		return payload, nil
	}
}

// EncodeUpdateTestError returns an encoder for errors returned by the
// UpdateTest knowledge endpoint.
func EncodeUpdateTestError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "test_not_found":
			var res knowledge.TestNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteTestResponse returns an encoder for responses returned by the
// knowledge DeleteTest endpoint.
func EncodeDeleteTestResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewDeleteTestResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDeleteTestRequest returns a decoder for requests sent to the knowledge
// DeleteTest endpoint.
func DecodeDeleteTestRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			testID       int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			testIDRaw := params["test_id"]
			v, err2 := strconv.ParseInt(testIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("test_id", testIDRaw, "integer"))
			}
			testID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteTestPayload(testID, sessionToken)

		return payload, nil
	}
}

// EncodeDeleteTestError returns an encoder for errors returned by the
// DeleteTest knowledge endpoint.
func EncodeDeleteTestError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "test_not_found":
			var res knowledge.TestNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetTestQuestionsResponse returns an encoder for responses returned by
// the knowledge GetTestQuestions endpoint.
func EncodeGetTestQuestionsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.QuestionsResponse)
		enc := encoder(ctx, w)
		body := NewGetTestQuestionsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetTestQuestionsRequest returns a decoder for requests sent to the
// knowledge GetTestQuestions endpoint.
func DecodeGetTestQuestionsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			testID       int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			testIDRaw := params["test_id"]
			v, err2 := strconv.ParseInt(testIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("test_id", testIDRaw, "integer"))
			}
			testID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetTestQuestionsPayload(testID, sessionToken)

		return payload, nil
	}
}

// EncodeGetTestQuestionsError returns an encoder for errors returned by the
// GetTestQuestions knowledge endpoint.
func EncodeGetTestQuestionsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "test_not_found":
			var res knowledge.TestNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeAddQuestionResponse returns an encoder for responses returned by the
// knowledge AddQuestion endpoint.
func EncodeAddQuestionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewAddQuestionResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeAddQuestionRequest returns a decoder for requests sent to the
// knowledge AddQuestion endpoint.
func DecodeAddQuestionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body AddQuestionRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateAddQuestionRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			testID       int64
			sessionToken string
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			testIDRaw := params["test_id"]
			v, err2 := strconv.ParseInt(testIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("test_id", testIDRaw, "integer"))
			}
			testID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewAddQuestionPayload(&body, testID, sessionToken)

		return payload, nil
	}
}

// EncodeAddQuestionError returns an encoder for errors returned by the
// AddQuestion knowledge endpoint.
func EncodeAddQuestionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "invalid_input":
			var res knowledge.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "test_not_found":
			var res knowledge.TestNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetQuestionByIDResponse returns an encoder for responses returned by
// the knowledge GetQuestionById endpoint.
func EncodeGetQuestionByIDResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.QuestionResponse)
		enc := encoder(ctx, w)
		body := NewGetQuestionByIDResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetQuestionByIDRequest returns a decoder for requests sent to the
// knowledge GetQuestionById endpoint.
func DecodeGetQuestionByIDRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			testID       int64
			questionID   int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			testIDRaw := params["test_id"]
			v, err2 := strconv.ParseInt(testIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("test_id", testIDRaw, "integer"))
			}
			testID = v
		}
		{
			questionIDRaw := params["question_id"]
			v, err2 := strconv.ParseInt(questionIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("question_id", questionIDRaw, "integer"))
			}
			questionID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetQuestionByIDPayload(testID, questionID, sessionToken)

		return payload, nil
	}
}

// EncodeGetQuestionByIDError returns an encoder for errors returned by the
// GetQuestionById knowledge endpoint.
func EncodeGetQuestionByIDError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "question_not_found":
			var res knowledge.QuestionNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "test_not_found":
			var res knowledge.TestNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateQuestionResponse returns an encoder for responses returned by
// the knowledge UpdateQuestion endpoint.
func EncodeUpdateQuestionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewUpdateQuestionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateQuestionRequest returns a decoder for requests sent to the
// knowledge UpdateQuestion endpoint.
func DecodeUpdateQuestionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateQuestionRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateQuestionRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			testID       int64
			questionID   int64
			sessionToken string
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			testIDRaw := params["test_id"]
			v, err2 := strconv.ParseInt(testIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("test_id", testIDRaw, "integer"))
			}
			testID = v
		}
		{
			questionIDRaw := params["question_id"]
			v, err2 := strconv.ParseInt(questionIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("question_id", questionIDRaw, "integer"))
			}
			questionID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateQuestionPayload(&body, testID, questionID, sessionToken)

		return payload, nil
	}
}

// EncodeUpdateQuestionError returns an encoder for errors returned by the
// UpdateQuestion knowledge endpoint.
func EncodeUpdateQuestionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "question_not_found":
			var res knowledge.QuestionNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "test_not_found":
			var res knowledge.TestNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteQuestionResponse returns an encoder for responses returned by
// the knowledge DeleteQuestion endpoint.
func EncodeDeleteQuestionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewDeleteQuestionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDeleteQuestionRequest returns a decoder for requests sent to the
// knowledge DeleteQuestion endpoint.
func DecodeDeleteQuestionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			testID       int64
			questionID   int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			testIDRaw := params["test_id"]
			v, err2 := strconv.ParseInt(testIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("test_id", testIDRaw, "integer"))
			}
			testID = v
		}
		{
			questionIDRaw := params["question_id"]
			v, err2 := strconv.ParseInt(questionIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("question_id", questionIDRaw, "integer"))
			}
			questionID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteQuestionPayload(testID, questionID, sessionToken)

		return payload, nil
	}
}

// EncodeDeleteQuestionError returns an encoder for errors returned by the
// DeleteQuestion knowledge endpoint.
func EncodeDeleteQuestionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "question_not_found":
			var res knowledge.QuestionNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "test_not_found":
			var res knowledge.TestNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetAvailableTestsResponse returns an encoder for responses returned by
// the knowledge GetAvailableTests endpoint.
func EncodeGetAvailableTestsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.TestsResponse)
		enc := encoder(ctx, w)
		body := NewGetAvailableTestsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetAvailableTestsRequest returns a decoder for requests sent to the
// knowledge GetAvailableTests endpoint.
func DecodeGetAvailableTestsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			sessionToken string
			err          error
			c            *http.Cookie
		)
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetAvailableTestsPayload(sessionToken)

		return payload, nil
	}
}

// EncodeGetAvailableTestsError returns an encoder for errors returned by the
// GetAvailableTests knowledge endpoint.
func EncodeGetAvailableTestsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetTestFormResponse returns an encoder for responses returned by the
// knowledge GetTestForm endpoint.
func EncodeGetTestFormResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.FormResponse)
		enc := encoder(ctx, w)
		body := NewGetTestFormResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetTestFormRequest returns a decoder for requests sent to the
// knowledge GetTestForm endpoint.
func DecodeGetTestFormRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			testID       int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			testIDRaw := params["test_id"]
			v, err2 := strconv.ParseInt(testIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("test_id", testIDRaw, "integer"))
			}
			testID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetTestFormPayload(testID, sessionToken)

		return payload, nil
	}
}

// EncodeGetTestFormError returns an encoder for errors returned by the
// GetTestForm knowledge endpoint.
func EncodeGetTestFormError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "test_already_submitted":
			var res knowledge.TestAlreadySubmitted
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "test_not_found":
			var res knowledge.TestNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeSubmitTestResponse returns an encoder for responses returned by the
// knowledge SubmitTest endpoint.
func EncodeSubmitTestResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.SubmitResponse)
		enc := encoder(ctx, w)
		body := NewSubmitTestResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeSubmitTestRequest returns a decoder for requests sent to the knowledge
// SubmitTest endpoint.
func DecodeSubmitTestRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body SubmitTestRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateSubmitTestRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			testID       int64
			sessionToken string
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			testIDRaw := params["test_id"]
			v, err2 := strconv.ParseInt(testIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("test_id", testIDRaw, "integer"))
			}
			testID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewSubmitTestPayload(&body, testID, sessionToken)

		return payload, nil
	}
}

// EncodeSubmitTestError returns an encoder for errors returned by the
// SubmitTest knowledge endpoint.
func EncodeSubmitTestError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "invalid_input":
			var res knowledge.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "test_already_submitted":
			var res knowledge.TestAlreadySubmitted
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "test_not_found":
			var res knowledge.TestNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetMySubmissionsResponse returns an encoder for responses returned by
// the knowledge GetMySubmissions endpoint.
func EncodeGetMySubmissionsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.SubmissionsResponse)
		enc := encoder(ctx, w)
		body := NewGetMySubmissionsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetMySubmissionsRequest returns a decoder for requests sent to the
// knowledge GetMySubmissions endpoint.
func DecodeGetMySubmissionsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			sessionToken string
			err          error
			c            *http.Cookie
		)
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetMySubmissionsPayload(sessionToken)

		return payload, nil
	}
}

// EncodeGetMySubmissionsError returns an encoder for errors returned by the
// GetMySubmissions knowledge endpoint.
func EncodeGetMySubmissionsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetSubmissionByIDResponse returns an encoder for responses returned by
// the knowledge GetSubmissionById endpoint.
func EncodeGetSubmissionByIDResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.SubmissionResponse)
		enc := encoder(ctx, w)
		body := NewGetSubmissionByIDResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSubmissionByIDRequest returns a decoder for requests sent to the
// knowledge GetSubmissionById endpoint.
func DecodeGetSubmissionByIDRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			submissionID int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			submissionIDRaw := params["submission_id"]
			v, err2 := strconv.ParseInt(submissionIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("submission_id", submissionIDRaw, "integer"))
			}
			submissionID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSubmissionByIDPayload(submissionID, sessionToken)

		return payload, nil
	}
}

// EncodeGetSubmissionByIDError returns an encoder for errors returned by the
// GetSubmissionById knowledge endpoint.
func EncodeGetSubmissionByIDError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "submission_not_found":
			var res knowledge.SubmissionNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetSubmissionResultResponse returns an encoder for responses returned
// by the knowledge GetSubmissionResult endpoint.
func EncodeGetSubmissionResultResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*knowledge.SubmissionResult)
		enc := encoder(ctx, w)
		body := NewGetSubmissionResultResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSubmissionResultRequest returns a decoder for requests sent to the
// knowledge GetSubmissionResult endpoint.
func DecodeGetSubmissionResultRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			submissionID int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			submissionIDRaw := params["submission_id"]
			v, err2 := strconv.ParseInt(submissionIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("submission_id", submissionIDRaw, "integer"))
			}
			submissionID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSubmissionResultPayload(submissionID, sessionToken)

		return payload, nil
	}
}

// EncodeGetSubmissionResultError returns an encoder for errors returned by the
// GetSubmissionResult knowledge endpoint.
func EncodeGetSubmissionResultError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "submission_not_found":
			var res knowledge.SubmissionNotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res knowledge.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalKnowledgeTestToTestResponseBody builds a value of type
// *TestResponseBody from a value of type *knowledge.Test.
func marshalKnowledgeTestToTestResponseBody(v *knowledge.Test) *TestResponseBody {
	res := &TestResponseBody{
		ID:            v.ID,
		Title:         v.Title,
		CreatedBy:     v.CreatedBy,
		CreatedAt:     v.CreatedAt,
		QuestionCount: v.QuestionCount,
	}

	return res
}

// marshalKnowledgeQuestionToQuestionResponseBody builds a value of type
// *QuestionResponseBody from a value of type *knowledge.Question.
func marshalKnowledgeQuestionToQuestionResponseBody(v *knowledge.Question) *QuestionResponseBody {
	res := &QuestionResponseBody{
		ID:            v.ID,
		TestID:        v.TestID,
		QuestionText:  v.QuestionText,
		OptionA:       v.OptionA,
		OptionB:       v.OptionB,
		OptionC:       v.OptionC,
		OptionD:       v.OptionD,
		CorrectAnswer: v.CorrectAnswer,
		QuestionOrder: v.QuestionOrder,
	}

	return res
}

// marshalKnowledgeQuestionFormToQuestionFormResponseBody builds a value of
// type *QuestionFormResponseBody from a value of type *knowledge.QuestionForm.
func marshalKnowledgeQuestionFormToQuestionFormResponseBody(v *knowledge.QuestionForm) *QuestionFormResponseBody {
	res := &QuestionFormResponseBody{
		ID:            v.ID,
		QuestionText:  v.QuestionText,
		OptionA:       v.OptionA,
		OptionB:       v.OptionB,
		OptionC:       v.OptionC,
		OptionD:       v.OptionD,
		QuestionOrder: v.QuestionOrder,
	}

	return res
}

// unmarshalAnswerRequestBodyToKnowledgeAnswer builds a value of type
// *knowledge.Answer from a value of type *AnswerRequestBody.
func unmarshalAnswerRequestBodyToKnowledgeAnswer(v *AnswerRequestBody) *knowledge.Answer {
	res := &knowledge.Answer{
		QuestionID:     *v.QuestionID,
		SelectedAnswer: *v.SelectedAnswer,
	}

	return res
}

// marshalKnowledgeSubmissionToSubmissionResponseBody builds a value of type
// *SubmissionResponseBody from a value of type *knowledge.Submission.
func marshalKnowledgeSubmissionToSubmissionResponseBody(v *knowledge.Submission) *SubmissionResponseBody {
	res := &SubmissionResponseBody{
		ID:          v.ID,
		TestID:      v.TestID,
		TestTitle:   v.TestTitle,
		Score:       v.Score,
		SubmittedAt: v.SubmittedAt,
	}

	return res
}

// marshalKnowledgeQuestionResultToQuestionResultResponseBody builds a value of
// type *QuestionResultResponseBody from a value of type
// *knowledge.QuestionResult.
func marshalKnowledgeQuestionResultToQuestionResultResponseBody(v *knowledge.QuestionResult) *QuestionResultResponseBody {
	res := &QuestionResultResponseBody{
		SelectedAnswer: v.SelectedAnswer,
		IsCorrect:      v.IsCorrect,
	}
	if v.Question != nil {
		res.Question = marshalKnowledgeQuestionToQuestionResponseBody(v.Question)
	}

	return res
}
