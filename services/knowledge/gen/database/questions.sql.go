// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: questions.sql

package knowledgedb

import (
	"context"
)

const createQuestion = `-- name: CreateQuestion :exec

INSERT INTO questions (
    test_id,
    question_text,
    option_a,
    option_b,
    option_c,
    option_d,
    correct_answer,
    question_order
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateQuestionParams struct {
	TestID        int64
	QuestionText  string
	OptionA       string
	OptionB       string
	OptionC       string
	OptionD       string
	CorrectAnswer int32
	QuestionOrder int32
}

// Questions queries - simplified
func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) error {
	_, err := q.db.Exec(ctx, createQuestion,
		arg.TestID,
		arg.QuestionText,
		arg.OptionA,
		arg.OptionB,
		arg.OptionC,
		arg.OptionD,
		arg.CorrectAnswer,
		arg.QuestionOrder,
	)
	return err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questions WHERE id = $1
`

func (q *Queries) DeleteQuestion(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteQuestion, id)
	return err
}

const getQuestionById = `-- name: GetQuestionById :one
SELECT id, test_id, question_text, option_a, option_b, option_c, option_d, correct_answer, question_order FROM questions WHERE id = $1
`

func (q *Queries) GetQuestionById(ctx context.Context, id int64) (Question, error) {
	row := q.db.QueryRow(ctx, getQuestionById, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.QuestionText,
		&i.OptionA,
		&i.OptionB,
		&i.OptionC,
		&i.OptionD,
		&i.CorrectAnswer,
		&i.QuestionOrder,
	)
	return i, err
}

const getQuestionsByTestId = `-- name: GetQuestionsByTestId :many
SELECT id, test_id, question_text, option_a, option_b, option_c, option_d, correct_answer, question_order FROM questions
WHERE test_id = $1
ORDER BY question_order ASC
`

func (q *Queries) GetQuestionsByTestId(ctx context.Context, testID int64) ([]Question, error) {
	rows, err := q.db.Query(ctx, getQuestionsByTestId, testID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Question
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.TestID,
			&i.QuestionText,
			&i.OptionA,
			&i.OptionB,
			&i.OptionC,
			&i.OptionD,
			&i.CorrectAnswer,
			&i.QuestionOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuestion = `-- name: UpdateQuestion :exec
UPDATE questions
SET
    question_text = $2,
    option_a = $3,
    option_b = $4,
    option_c = $5,
    option_d = $6,
    correct_answer = $7
WHERE id = $1
`

type UpdateQuestionParams struct {
	ID            int64
	QuestionText  string
	OptionA       string
	OptionB       string
	OptionC       string
	OptionD       string
	CorrectAnswer int32
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) error {
	_, err := q.db.Exec(ctx, updateQuestion,
		arg.ID,
		arg.QuestionText,
		arg.OptionA,
		arg.OptionB,
		arg.OptionC,
		arg.OptionD,
		arg.CorrectAnswer,
	)
	return err
}
