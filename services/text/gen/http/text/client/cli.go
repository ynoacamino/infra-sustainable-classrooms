// Code generated by goa v3.21.1, DO NOT EDIT.
//
// text HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/text/design/api
// -o ./services/text/

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	text "github.com/ynoacamino/infra-sustainable-classrooms/services/text/gen/text"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateCoursePayload builds the payload for the text CreateCourse
// endpoint from CLI flags.
func BuildCreateCoursePayload(textCreateCourseBody string, textCreateCourseSessionToken string) (*text.CreateCoursePayload, error) {
	var err error
	var body CreateCourseRequestBody
	{
		err = json.Unmarshal([]byte(textCreateCourseBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Learn the basics of Go programming language.\",\n      \"imageUrl\": \"https://example.com/course-image.jpg\",\n      \"title\": \"Introduction to Go\"\n   }'")
		}
		if utf8.RuneCountInString(body.Title) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 3, true))
		}
		if utf8.RuneCountInString(body.Title) > 150 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 150, false))
		}
		if utf8.RuneCountInString(body.Description) < 10 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", body.Description, utf8.RuneCountInString(body.Description), 10, true))
		}
		if utf8.RuneCountInString(body.Description) > 300 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", body.Description, utf8.RuneCountInString(body.Description), 300, false))
		}
		if body.ImageURL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.imageUrl", *body.ImageURL, goa.FormatURI))
		}
		if body.ImageURL != nil {
			if utf8.RuneCountInString(*body.ImageURL) < 5 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.imageUrl", *body.ImageURL, utf8.RuneCountInString(*body.ImageURL), 5, true))
			}
		}
		if body.ImageURL != nil {
			if utf8.RuneCountInString(*body.ImageURL) > 500 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.imageUrl", *body.ImageURL, utf8.RuneCountInString(*body.ImageURL), 500, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken string
	{
		sessionToken = textCreateCourseSessionToken
	}
	v := &text.CreateCoursePayload{
		Title:       body.Title,
		Description: body.Description,
		ImageURL:    body.ImageURL,
	}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetCoursePayload builds the payload for the text GetCourse endpoint
// from CLI flags.
func BuildGetCoursePayload(textGetCourseCourseID string, textGetCourseSessionToken string) (*text.GetCoursePayload, error) {
	var err error
	var courseID int64
	{
		courseID, err = strconv.ParseInt(textGetCourseCourseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for courseID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textGetCourseSessionToken
	}
	v := &text.GetCoursePayload{}
	v.CourseID = courseID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildListCoursesPayload builds the payload for the text ListCourses endpoint
// from CLI flags.
func BuildListCoursesPayload(textListCoursesSessionToken string) (*text.ListCoursesPayload, error) {
	var sessionToken string
	{
		sessionToken = textListCoursesSessionToken
	}
	v := &text.ListCoursesPayload{}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildDeleteCoursePayload builds the payload for the text DeleteCourse
// endpoint from CLI flags.
func BuildDeleteCoursePayload(textDeleteCourseCourseID string, textDeleteCourseSessionToken string) (*text.DeleteCoursePayload, error) {
	var err error
	var courseID int64
	{
		courseID, err = strconv.ParseInt(textDeleteCourseCourseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for courseID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textDeleteCourseSessionToken
	}
	v := &text.DeleteCoursePayload{}
	v.CourseID = courseID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildUpdateCoursePayload builds the payload for the text UpdateCourse
// endpoint from CLI flags.
func BuildUpdateCoursePayload(textUpdateCourseBody string, textUpdateCourseCourseID string, textUpdateCourseSessionToken string) (*text.UpdateCoursePayload, error) {
	var err error
	var body UpdateCourseRequestBody
	{
		err = json.Unmarshal([]byte(textUpdateCourseBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Deep dive into Go programming language features.\",\n      \"imageUrl\": \"https://example.com/updated-course-image.jpg\",\n      \"title\": \"Advanced Go Programming\"\n   }'")
		}
		if body.Title != nil {
			if utf8.RuneCountInString(*body.Title) < 3 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 3, true))
			}
		}
		if body.Title != nil {
			if utf8.RuneCountInString(*body.Title) > 150 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 150, false))
			}
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) < 10 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 10, true))
			}
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 300 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 300, false))
			}
		}
		if body.ImageURL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.imageUrl", *body.ImageURL, goa.FormatURI))
		}
		if body.ImageURL != nil {
			if utf8.RuneCountInString(*body.ImageURL) < 5 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.imageUrl", *body.ImageURL, utf8.RuneCountInString(*body.ImageURL), 5, true))
			}
		}
		if body.ImageURL != nil {
			if utf8.RuneCountInString(*body.ImageURL) > 500 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.imageUrl", *body.ImageURL, utf8.RuneCountInString(*body.ImageURL), 500, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var courseID int64
	{
		courseID, err = strconv.ParseInt(textUpdateCourseCourseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for courseID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textUpdateCourseSessionToken
	}
	v := &text.UpdateCoursePayload{
		Title:       body.Title,
		Description: body.Description,
		ImageURL:    body.ImageURL,
	}
	v.CourseID = courseID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildCreateSectionPayload builds the payload for the text CreateSection
// endpoint from CLI flags.
func BuildCreateSectionPayload(textCreateSectionBody string, textCreateSectionCourseID string, textCreateSectionSessionToken string) (*text.CreateSectionPayload, error) {
	var err error
	var body CreateSectionRequestBody
	{
		err = json.Unmarshal([]byte(textCreateSectionBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Introduction to the course structure.\",\n      \"order\": 1,\n      \"title\": \"Getting Started\"\n   }'")
		}
		if utf8.RuneCountInString(body.Title) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 3, true))
		}
		if utf8.RuneCountInString(body.Title) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 100, false))
		}
		if utf8.RuneCountInString(body.Description) < 5 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", body.Description, utf8.RuneCountInString(body.Description), 5, true))
		}
		if utf8.RuneCountInString(body.Description) > 200 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", body.Description, utf8.RuneCountInString(body.Description), 200, false))
		}
		if body.Order != nil {
			if *body.Order < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.order", *body.Order, 1, true))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var courseID int64
	{
		courseID, err = strconv.ParseInt(textCreateSectionCourseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for courseID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textCreateSectionSessionToken
	}
	v := &text.CreateSectionPayload{
		Title:       body.Title,
		Description: body.Description,
		Order:       body.Order,
	}
	v.CourseID = courseID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetSectionPayload builds the payload for the text GetSection endpoint
// from CLI flags.
func BuildGetSectionPayload(textGetSectionSectionID string, textGetSectionSessionToken string) (*text.GetSectionPayload, error) {
	var err error
	var sectionID int64
	{
		sectionID, err = strconv.ParseInt(textGetSectionSectionID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for sectionID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textGetSectionSessionToken
	}
	v := &text.GetSectionPayload{}
	v.SectionID = sectionID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildListSectionsPayload builds the payload for the text ListSections
// endpoint from CLI flags.
func BuildListSectionsPayload(textListSectionsCourseID string, textListSectionsSessionToken string) (*text.ListSectionsPayload, error) {
	var err error
	var courseID int64
	{
		courseID, err = strconv.ParseInt(textListSectionsCourseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for courseID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textListSectionsSessionToken
	}
	v := &text.ListSectionsPayload{}
	v.CourseID = courseID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildUpdateSectionPayload builds the payload for the text UpdateSection
// endpoint from CLI flags.
func BuildUpdateSectionPayload(textUpdateSectionBody string, textUpdateSectionSectionID string, textUpdateSectionSessionToken string) (*text.UpdateSectionPayload, error) {
	var err error
	var body UpdateSectionRequestBody
	{
		err = json.Unmarshal([]byte(textUpdateSectionBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Updated section description.\",\n      \"order\": 2,\n      \"title\": \"Updated Section Title.\"\n   }'")
		}
		if body.Title != nil {
			if utf8.RuneCountInString(*body.Title) < 3 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 3, true))
			}
		}
		if body.Title != nil {
			if utf8.RuneCountInString(*body.Title) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 100, false))
			}
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) < 5 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 5, true))
			}
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 200 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 200, false))
			}
		}
		if body.Order != nil {
			if *body.Order < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.order", *body.Order, 1, true))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var sectionID int64
	{
		sectionID, err = strconv.ParseInt(textUpdateSectionSectionID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for sectionID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textUpdateSectionSessionToken
	}
	v := &text.UpdateSectionPayload{
		Title:       body.Title,
		Description: body.Description,
		Order:       body.Order,
	}
	v.SectionID = sectionID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildDeleteSectionPayload builds the payload for the text DeleteSection
// endpoint from CLI flags.
func BuildDeleteSectionPayload(textDeleteSectionSectionID string, textDeleteSectionSessionToken string) (*text.DeleteSectionPayload, error) {
	var err error
	var sectionID int64
	{
		sectionID, err = strconv.ParseInt(textDeleteSectionSectionID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for sectionID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textDeleteSectionSessionToken
	}
	v := &text.DeleteSectionPayload{}
	v.SectionID = sectionID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildCreateArticlePayload builds the payload for the text CreateArticle
// endpoint from CLI flags.
func BuildCreateArticlePayload(textCreateArticleBody string, textCreateArticleSectionID string, textCreateArticleSessionToken string) (*text.CreateArticlePayload, error) {
	var err error
	var body CreateArticleRequestBody
	{
		err = json.Unmarshal([]byte(textCreateArticleBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"content\": \"Go is an open source programming language...\",\n      \"title\": \"What is Go?\"\n   }'")
		}
		if utf8.RuneCountInString(body.Title) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 3, true))
		}
		if utf8.RuneCountInString(body.Title) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 100, false))
		}
		if utf8.RuneCountInString(body.Content) < 10 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.content", body.Content, utf8.RuneCountInString(body.Content), 10, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var sectionID int64
	{
		sectionID, err = strconv.ParseInt(textCreateArticleSectionID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for sectionID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textCreateArticleSessionToken
	}
	v := &text.CreateArticlePayload{
		Title:   body.Title,
		Content: body.Content,
	}
	v.SectionID = sectionID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetArticlePayload builds the payload for the text GetArticle endpoint
// from CLI flags.
func BuildGetArticlePayload(textGetArticleArticleID string, textGetArticleSessionToken string) (*text.GetArticlePayload, error) {
	var err error
	var articleID int64
	{
		articleID, err = strconv.ParseInt(textGetArticleArticleID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for articleID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textGetArticleSessionToken
	}
	v := &text.GetArticlePayload{}
	v.ArticleID = articleID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildListArticlesPayload builds the payload for the text ListArticles
// endpoint from CLI flags.
func BuildListArticlesPayload(textListArticlesSectionID string, textListArticlesSessionToken string) (*text.ListArticlesPayload, error) {
	var err error
	var sectionID int64
	{
		sectionID, err = strconv.ParseInt(textListArticlesSectionID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for sectionID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textListArticlesSessionToken
	}
	v := &text.ListArticlesPayload{}
	v.SectionID = sectionID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildUpdateArticlePayload builds the payload for the text UpdateArticle
// endpoint from CLI flags.
func BuildUpdateArticlePayload(textUpdateArticleBody string, textUpdateArticleArticleID string, textUpdateArticleSessionToken string) (*text.UpdateArticlePayload, error) {
	var err error
	var body UpdateArticleRequestBody
	{
		err = json.Unmarshal([]byte(textUpdateArticleBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"content\": \"Updated article content...\",\n      \"title\": \"Updated Article Title\"\n   }'")
		}
		if body.Title != nil {
			if utf8.RuneCountInString(*body.Title) < 3 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 3, true))
			}
		}
		if body.Title != nil {
			if utf8.RuneCountInString(*body.Title) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 100, false))
			}
		}
		if body.Content != nil {
			if utf8.RuneCountInString(*body.Content) < 10 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.content", *body.Content, utf8.RuneCountInString(*body.Content), 10, true))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var articleID int64
	{
		articleID, err = strconv.ParseInt(textUpdateArticleArticleID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for articleID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textUpdateArticleSessionToken
	}
	v := &text.UpdateArticlePayload{
		Title:   body.Title,
		Content: body.Content,
	}
	v.ArticleID = articleID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildDeleteArticlePayload builds the payload for the text DeleteArticle
// endpoint from CLI flags.
func BuildDeleteArticlePayload(textDeleteArticleArticleID string, textDeleteArticleSessionToken string) (*text.DeleteArticlePayload, error) {
	var err error
	var articleID int64
	{
		articleID, err = strconv.ParseInt(textDeleteArticleArticleID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for articleID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = textDeleteArticleSessionToken
	}
	v := &text.DeleteArticlePayload{}
	v.ArticleID = articleID
	v.SessionToken = sessionToken

	return v, nil
}
