// Code generated by goa v3.21.1, DO NOT EDIT.
//
// text HTTP server
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/text/design/api
// -o ./services/text/

package server

import (
	"context"
	"net/http"

	text "github.com/ynoacamino/infra-sustainable-classrooms/services/text/gen/text"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// Server lists the text service endpoint HTTP handlers.
type Server struct {
	Mounts        []*MountPoint
	CreateCourse  http.Handler
	GetCourse     http.Handler
	ListCourses   http.Handler
	DeleteCourse  http.Handler
	UpdateCourse  http.Handler
	CreateSection http.Handler
	GetSection    http.Handler
	ListSections  http.Handler
	UpdateSection http.Handler
	DeleteSection http.Handler
	CreateArticle http.Handler
	GetArticle    http.Handler
	ListArticles  http.Handler
	UpdateArticle http.Handler
	DeleteArticle http.Handler
}

// MountPoint holds information about the mounted endpoints.
type MountPoint struct {
	// Method is the name of the service method served by the mounted HTTP handler.
	Method string
	// Verb is the HTTP method used to match requests to the mounted handler.
	Verb string
	// Pattern is the HTTP request path pattern used to match requests to the
	// mounted handler.
	Pattern string
}

// New instantiates HTTP handlers for all the text service endpoints using the
// provided encoder and decoder. The handlers are mounted on the given mux
// using the HTTP verb and path defined in the design. errhandler is called
// whenever a response fails to be encoded. formatter is used to format errors
// returned by the service methods prior to encoding. Both errhandler and
// formatter are optional and can be nil.
func New(
	e *text.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) *Server {
	return &Server{
		Mounts: []*MountPoint{
			{"CreateCourse", "POST", "/api/text/courses"},
			{"GetCourse", "GET", "/api/text/courses/{course_id}"},
			{"ListCourses", "GET", "/api/text/courses"},
			{"DeleteCourse", "DELETE", "/api/text/courses/{course_id}"},
			{"UpdateCourse", "PATCH", "/api/text/courses/{course_id}"},
			{"CreateSection", "POST", "/api/text/courses/{course_id}/sections"},
			{"GetSection", "GET", "/api/text/sections/{section_id}"},
			{"ListSections", "GET", "/api/text/courses/{course_id}/sections"},
			{"UpdateSection", "PATCH", "/api/text/sections/{section_id}"},
			{"DeleteSection", "DELETE", "/api/text/sections/{section_id}"},
			{"CreateArticle", "POST", "/api/text/sections/{section_id}/articles"},
			{"GetArticle", "GET", "/api/text/articles/{article_id}"},
			{"ListArticles", "GET", "/api/text/sections/{section_id}/articles"},
			{"UpdateArticle", "PATCH", "/api/text/articles/{article_id}"},
			{"DeleteArticle", "DELETE", "/api/text/articles/{article_id}"},
		},
		CreateCourse:  NewCreateCourseHandler(e.CreateCourse, mux, decoder, encoder, errhandler, formatter),
		GetCourse:     NewGetCourseHandler(e.GetCourse, mux, decoder, encoder, errhandler, formatter),
		ListCourses:   NewListCoursesHandler(e.ListCourses, mux, decoder, encoder, errhandler, formatter),
		DeleteCourse:  NewDeleteCourseHandler(e.DeleteCourse, mux, decoder, encoder, errhandler, formatter),
		UpdateCourse:  NewUpdateCourseHandler(e.UpdateCourse, mux, decoder, encoder, errhandler, formatter),
		CreateSection: NewCreateSectionHandler(e.CreateSection, mux, decoder, encoder, errhandler, formatter),
		GetSection:    NewGetSectionHandler(e.GetSection, mux, decoder, encoder, errhandler, formatter),
		ListSections:  NewListSectionsHandler(e.ListSections, mux, decoder, encoder, errhandler, formatter),
		UpdateSection: NewUpdateSectionHandler(e.UpdateSection, mux, decoder, encoder, errhandler, formatter),
		DeleteSection: NewDeleteSectionHandler(e.DeleteSection, mux, decoder, encoder, errhandler, formatter),
		CreateArticle: NewCreateArticleHandler(e.CreateArticle, mux, decoder, encoder, errhandler, formatter),
		GetArticle:    NewGetArticleHandler(e.GetArticle, mux, decoder, encoder, errhandler, formatter),
		ListArticles:  NewListArticlesHandler(e.ListArticles, mux, decoder, encoder, errhandler, formatter),
		UpdateArticle: NewUpdateArticleHandler(e.UpdateArticle, mux, decoder, encoder, errhandler, formatter),
		DeleteArticle: NewDeleteArticleHandler(e.DeleteArticle, mux, decoder, encoder, errhandler, formatter),
	}
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "text" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.CreateCourse = m(s.CreateCourse)
	s.GetCourse = m(s.GetCourse)
	s.ListCourses = m(s.ListCourses)
	s.DeleteCourse = m(s.DeleteCourse)
	s.UpdateCourse = m(s.UpdateCourse)
	s.CreateSection = m(s.CreateSection)
	s.GetSection = m(s.GetSection)
	s.ListSections = m(s.ListSections)
	s.UpdateSection = m(s.UpdateSection)
	s.DeleteSection = m(s.DeleteSection)
	s.CreateArticle = m(s.CreateArticle)
	s.GetArticle = m(s.GetArticle)
	s.ListArticles = m(s.ListArticles)
	s.UpdateArticle = m(s.UpdateArticle)
	s.DeleteArticle = m(s.DeleteArticle)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return text.MethodNames[:] }

// Mount configures the mux to serve the text endpoints.
func Mount(mux goahttp.Muxer, h *Server) {
	MountCreateCourseHandler(mux, h.CreateCourse)
	MountGetCourseHandler(mux, h.GetCourse)
	MountListCoursesHandler(mux, h.ListCourses)
	MountDeleteCourseHandler(mux, h.DeleteCourse)
	MountUpdateCourseHandler(mux, h.UpdateCourse)
	MountCreateSectionHandler(mux, h.CreateSection)
	MountGetSectionHandler(mux, h.GetSection)
	MountListSectionsHandler(mux, h.ListSections)
	MountUpdateSectionHandler(mux, h.UpdateSection)
	MountDeleteSectionHandler(mux, h.DeleteSection)
	MountCreateArticleHandler(mux, h.CreateArticle)
	MountGetArticleHandler(mux, h.GetArticle)
	MountListArticlesHandler(mux, h.ListArticles)
	MountUpdateArticleHandler(mux, h.UpdateArticle)
	MountDeleteArticleHandler(mux, h.DeleteArticle)
}

// Mount configures the mux to serve the text endpoints.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// MountCreateCourseHandler configures the mux to serve the "text" service
// "CreateCourse" endpoint.
func MountCreateCourseHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/api/text/courses", f)
}

// NewCreateCourseHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "CreateCourse" endpoint.
func NewCreateCourseHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateCourseRequest(mux, decoder)
		encodeResponse = EncodeCreateCourseResponse(encoder)
		encodeError    = EncodeCreateCourseError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateCourse")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetCourseHandler configures the mux to serve the "text" service
// "GetCourse" endpoint.
func MountGetCourseHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/api/text/courses/{course_id}", f)
}

// NewGetCourseHandler creates a HTTP handler which loads the HTTP request and
// calls the "text" service "GetCourse" endpoint.
func NewGetCourseHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetCourseRequest(mux, decoder)
		encodeResponse = EncodeGetCourseResponse(encoder)
		encodeError    = EncodeGetCourseError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetCourse")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListCoursesHandler configures the mux to serve the "text" service
// "ListCourses" endpoint.
func MountListCoursesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/api/text/courses", f)
}

// NewListCoursesHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "ListCourses" endpoint.
func NewListCoursesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListCoursesRequest(mux, decoder)
		encodeResponse = EncodeListCoursesResponse(encoder)
		encodeError    = EncodeListCoursesError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListCourses")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteCourseHandler configures the mux to serve the "text" service
// "DeleteCourse" endpoint.
func MountDeleteCourseHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/api/text/courses/{course_id}", f)
}

// NewDeleteCourseHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "DeleteCourse" endpoint.
func NewDeleteCourseHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteCourseRequest(mux, decoder)
		encodeResponse = EncodeDeleteCourseResponse(encoder)
		encodeError    = EncodeDeleteCourseError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteCourse")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateCourseHandler configures the mux to serve the "text" service
// "UpdateCourse" endpoint.
func MountUpdateCourseHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/api/text/courses/{course_id}", f)
}

// NewUpdateCourseHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "UpdateCourse" endpoint.
func NewUpdateCourseHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateCourseRequest(mux, decoder)
		encodeResponse = EncodeUpdateCourseResponse(encoder)
		encodeError    = EncodeUpdateCourseError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateCourse")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateSectionHandler configures the mux to serve the "text" service
// "CreateSection" endpoint.
func MountCreateSectionHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/api/text/courses/{course_id}/sections", f)
}

// NewCreateSectionHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "CreateSection" endpoint.
func NewCreateSectionHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateSectionRequest(mux, decoder)
		encodeResponse = EncodeCreateSectionResponse(encoder)
		encodeError    = EncodeCreateSectionError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateSection")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetSectionHandler configures the mux to serve the "text" service
// "GetSection" endpoint.
func MountGetSectionHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/api/text/sections/{section_id}", f)
}

// NewGetSectionHandler creates a HTTP handler which loads the HTTP request and
// calls the "text" service "GetSection" endpoint.
func NewGetSectionHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetSectionRequest(mux, decoder)
		encodeResponse = EncodeGetSectionResponse(encoder)
		encodeError    = EncodeGetSectionError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetSection")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListSectionsHandler configures the mux to serve the "text" service
// "ListSections" endpoint.
func MountListSectionsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/api/text/courses/{course_id}/sections", f)
}

// NewListSectionsHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "ListSections" endpoint.
func NewListSectionsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListSectionsRequest(mux, decoder)
		encodeResponse = EncodeListSectionsResponse(encoder)
		encodeError    = EncodeListSectionsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListSections")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateSectionHandler configures the mux to serve the "text" service
// "UpdateSection" endpoint.
func MountUpdateSectionHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/api/text/sections/{section_id}", f)
}

// NewUpdateSectionHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "UpdateSection" endpoint.
func NewUpdateSectionHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateSectionRequest(mux, decoder)
		encodeResponse = EncodeUpdateSectionResponse(encoder)
		encodeError    = EncodeUpdateSectionError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateSection")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteSectionHandler configures the mux to serve the "text" service
// "DeleteSection" endpoint.
func MountDeleteSectionHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/api/text/sections/{section_id}", f)
}

// NewDeleteSectionHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "DeleteSection" endpoint.
func NewDeleteSectionHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteSectionRequest(mux, decoder)
		encodeResponse = EncodeDeleteSectionResponse(encoder)
		encodeError    = EncodeDeleteSectionError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteSection")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateArticleHandler configures the mux to serve the "text" service
// "CreateArticle" endpoint.
func MountCreateArticleHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/api/text/sections/{section_id}/articles", f)
}

// NewCreateArticleHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "CreateArticle" endpoint.
func NewCreateArticleHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateArticleRequest(mux, decoder)
		encodeResponse = EncodeCreateArticleResponse(encoder)
		encodeError    = EncodeCreateArticleError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateArticle")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetArticleHandler configures the mux to serve the "text" service
// "GetArticle" endpoint.
func MountGetArticleHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/api/text/articles/{article_id}", f)
}

// NewGetArticleHandler creates a HTTP handler which loads the HTTP request and
// calls the "text" service "GetArticle" endpoint.
func NewGetArticleHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetArticleRequest(mux, decoder)
		encodeResponse = EncodeGetArticleResponse(encoder)
		encodeError    = EncodeGetArticleError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetArticle")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListArticlesHandler configures the mux to serve the "text" service
// "ListArticles" endpoint.
func MountListArticlesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/api/text/sections/{section_id}/articles", f)
}

// NewListArticlesHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "ListArticles" endpoint.
func NewListArticlesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListArticlesRequest(mux, decoder)
		encodeResponse = EncodeListArticlesResponse(encoder)
		encodeError    = EncodeListArticlesError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListArticles")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateArticleHandler configures the mux to serve the "text" service
// "UpdateArticle" endpoint.
func MountUpdateArticleHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/api/text/articles/{article_id}", f)
}

// NewUpdateArticleHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "UpdateArticle" endpoint.
func NewUpdateArticleHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateArticleRequest(mux, decoder)
		encodeResponse = EncodeUpdateArticleResponse(encoder)
		encodeError    = EncodeUpdateArticleError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateArticle")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteArticleHandler configures the mux to serve the "text" service
// "DeleteArticle" endpoint.
func MountDeleteArticleHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/api/text/articles/{article_id}", f)
}

// NewDeleteArticleHandler creates a HTTP handler which loads the HTTP request
// and calls the "text" service "DeleteArticle" endpoint.
func NewDeleteArticleHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteArticleRequest(mux, decoder)
		encodeResponse = EncodeDeleteArticleResponse(encoder)
		encodeError    = EncodeDeleteArticleError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteArticle")
		ctx = context.WithValue(ctx, goa.ServiceKey, "text")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}
