// Code generated by goa v3.21.1, DO NOT EDIT.
//
// text HTTP server encoders and decoders
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/text/design/api
// -o ./services/text/

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strconv"

	text "github.com/ynoacamino/infra-sustainable-classrooms/services/text/gen/text"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeCreateCourseResponse returns an encoder for responses returned by the
// text CreateCourse endpoint.
func EncodeCreateCourseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewCreateCourseResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateCourseRequest returns a decoder for requests sent to the text
// CreateCourse endpoint.
func DecodeCreateCourseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateCourseRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateCourseRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			sessionToken string
			c            *http.Cookie
		)
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateCoursePayload(&body, sessionToken)

		return payload, nil
	}
}

// EncodeCreateCourseError returns an encoder for errors returned by the
// CreateCourse text endpoint.
func EncodeCreateCourseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "permission_denied":
			var res text.PermissionDenied
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetCourseResponse returns an encoder for responses returned by the
// text GetCourse endpoint.
func EncodeGetCourseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.Course)
		enc := encoder(ctx, w)
		body := NewGetCourseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetCourseRequest returns a decoder for requests sent to the text
// GetCourse endpoint.
func DecodeGetCourseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			courseID     int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			courseIDRaw := params["course_id"]
			v, err2 := strconv.ParseInt(courseIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("course_id", courseIDRaw, "integer"))
			}
			courseID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetCoursePayload(courseID, sessionToken)

		return payload, nil
	}
}

// EncodeGetCourseError returns an encoder for errors returned by the GetCourse
// text endpoint.
func EncodeGetCourseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListCoursesResponse returns an encoder for responses returned by the
// text ListCourses endpoint.
func EncodeListCoursesResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]*text.Course)
		enc := encoder(ctx, w)
		body := NewListCoursesResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListCoursesRequest returns a decoder for requests sent to the text
// ListCourses endpoint.
func DecodeListCoursesRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			sessionToken string
			err          error
			c            *http.Cookie
		)
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewListCoursesPayload(sessionToken)

		return payload, nil
	}
}

// EncodeListCoursesError returns an encoder for errors returned by the
// ListCourses text endpoint.
func EncodeListCoursesError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteCourseResponse returns an encoder for responses returned by the
// text DeleteCourse endpoint.
func EncodeDeleteCourseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewDeleteCourseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDeleteCourseRequest returns a decoder for requests sent to the text
// DeleteCourse endpoint.
func DecodeDeleteCourseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			courseID     int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			courseIDRaw := params["course_id"]
			v, err2 := strconv.ParseInt(courseIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("course_id", courseIDRaw, "integer"))
			}
			courseID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteCoursePayload(courseID, sessionToken)

		return payload, nil
	}
}

// EncodeDeleteCourseError returns an encoder for errors returned by the
// DeleteCourse text endpoint.
func EncodeDeleteCourseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "permission_denied":
			var res text.PermissionDenied
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateCourseResponse returns an encoder for responses returned by the
// text UpdateCourse endpoint.
func EncodeUpdateCourseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewUpdateCourseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateCourseRequest returns a decoder for requests sent to the text
// UpdateCourse endpoint.
func DecodeUpdateCourseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateCourseRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateCourseRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			courseID     int64
			sessionToken string
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			courseIDRaw := params["course_id"]
			v, err2 := strconv.ParseInt(courseIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("course_id", courseIDRaw, "integer"))
			}
			courseID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateCoursePayload(&body, courseID, sessionToken)

		return payload, nil
	}
}

// EncodeUpdateCourseError returns an encoder for errors returned by the
// UpdateCourse text endpoint.
func EncodeUpdateCourseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "permission_denied":
			var res text.PermissionDenied
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateSectionResponse returns an encoder for responses returned by the
// text CreateSection endpoint.
func EncodeCreateSectionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewCreateSectionResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateSectionRequest returns a decoder for requests sent to the text
// CreateSection endpoint.
func DecodeCreateSectionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateSectionRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateSectionRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			courseID     int64
			sessionToken string
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			courseIDRaw := params["course_id"]
			v, err2 := strconv.ParseInt(courseIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("course_id", courseIDRaw, "integer"))
			}
			courseID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateSectionPayload(&body, courseID, sessionToken)

		return payload, nil
	}
}

// EncodeCreateSectionError returns an encoder for errors returned by the
// CreateSection text endpoint.
func EncodeCreateSectionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "permission_denied":
			var res text.PermissionDenied
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetSectionResponse returns an encoder for responses returned by the
// text GetSection endpoint.
func EncodeGetSectionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.Section)
		enc := encoder(ctx, w)
		body := NewGetSectionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetSectionRequest returns a decoder for requests sent to the text
// GetSection endpoint.
func DecodeGetSectionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			sectionID    int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			sectionIDRaw := params["section_id"]
			v, err2 := strconv.ParseInt(sectionIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("section_id", sectionIDRaw, "integer"))
			}
			sectionID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetSectionPayload(sectionID, sessionToken)

		return payload, nil
	}
}

// EncodeGetSectionError returns an encoder for errors returned by the
// GetSection text endpoint.
func EncodeGetSectionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListSectionsResponse returns an encoder for responses returned by the
// text ListSections endpoint.
func EncodeListSectionsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]*text.Section)
		enc := encoder(ctx, w)
		body := NewListSectionsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListSectionsRequest returns a decoder for requests sent to the text
// ListSections endpoint.
func DecodeListSectionsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			courseID     int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			courseIDRaw := params["course_id"]
			v, err2 := strconv.ParseInt(courseIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("course_id", courseIDRaw, "integer"))
			}
			courseID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewListSectionsPayload(courseID, sessionToken)

		return payload, nil
	}
}

// EncodeListSectionsError returns an encoder for errors returned by the
// ListSections text endpoint.
func EncodeListSectionsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateSectionResponse returns an encoder for responses returned by the
// text UpdateSection endpoint.
func EncodeUpdateSectionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewUpdateSectionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateSectionRequest returns a decoder for requests sent to the text
// UpdateSection endpoint.
func DecodeUpdateSectionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateSectionRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateSectionRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			sectionID    int64
			sessionToken string
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			sectionIDRaw := params["section_id"]
			v, err2 := strconv.ParseInt(sectionIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("section_id", sectionIDRaw, "integer"))
			}
			sectionID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateSectionPayload(&body, sectionID, sessionToken)

		return payload, nil
	}
}

// EncodeUpdateSectionError returns an encoder for errors returned by the
// UpdateSection text endpoint.
func EncodeUpdateSectionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "permission_denied":
			var res text.PermissionDenied
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteSectionResponse returns an encoder for responses returned by the
// text DeleteSection endpoint.
func EncodeDeleteSectionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewDeleteSectionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDeleteSectionRequest returns a decoder for requests sent to the text
// DeleteSection endpoint.
func DecodeDeleteSectionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			sectionID    int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			sectionIDRaw := params["section_id"]
			v, err2 := strconv.ParseInt(sectionIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("section_id", sectionIDRaw, "integer"))
			}
			sectionID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteSectionPayload(sectionID, sessionToken)

		return payload, nil
	}
}

// EncodeDeleteSectionError returns an encoder for errors returned by the
// DeleteSection text endpoint.
func EncodeDeleteSectionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "permission_denied":
			var res text.PermissionDenied
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateArticleResponse returns an encoder for responses returned by the
// text CreateArticle endpoint.
func EncodeCreateArticleResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewCreateArticleResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateArticleRequest returns a decoder for requests sent to the text
// CreateArticle endpoint.
func DecodeCreateArticleRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateArticleRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateArticleRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			sectionID    int64
			sessionToken string
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			sectionIDRaw := params["section_id"]
			v, err2 := strconv.ParseInt(sectionIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("section_id", sectionIDRaw, "integer"))
			}
			sectionID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateArticlePayload(&body, sectionID, sessionToken)

		return payload, nil
	}
}

// EncodeCreateArticleError returns an encoder for errors returned by the
// CreateArticle text endpoint.
func EncodeCreateArticleError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "permission_denied":
			var res text.PermissionDenied
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetArticleResponse returns an encoder for responses returned by the
// text GetArticle endpoint.
func EncodeGetArticleResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.Article)
		enc := encoder(ctx, w)
		body := NewGetArticleResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetArticleRequest returns a decoder for requests sent to the text
// GetArticle endpoint.
func DecodeGetArticleRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			articleID    int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			articleIDRaw := params["article_id"]
			v, err2 := strconv.ParseInt(articleIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("article_id", articleIDRaw, "integer"))
			}
			articleID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetArticlePayload(articleID, sessionToken)

		return payload, nil
	}
}

// EncodeGetArticleError returns an encoder for errors returned by the
// GetArticle text endpoint.
func EncodeGetArticleError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListArticlesResponse returns an encoder for responses returned by the
// text ListArticles endpoint.
func EncodeListArticlesResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]*text.Article)
		enc := encoder(ctx, w)
		body := NewListArticlesResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListArticlesRequest returns a decoder for requests sent to the text
// ListArticles endpoint.
func DecodeListArticlesRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			sectionID    int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			sectionIDRaw := params["section_id"]
			v, err2 := strconv.ParseInt(sectionIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("section_id", sectionIDRaw, "integer"))
			}
			sectionID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewListArticlesPayload(sectionID, sessionToken)

		return payload, nil
	}
}

// EncodeListArticlesError returns an encoder for errors returned by the
// ListArticles text endpoint.
func EncodeListArticlesError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateArticleResponse returns an encoder for responses returned by the
// text UpdateArticle endpoint.
func EncodeUpdateArticleResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewUpdateArticleResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateArticleRequest returns a decoder for requests sent to the text
// UpdateArticle endpoint.
func DecodeUpdateArticleRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateArticleRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateArticleRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			articleID    int64
			sessionToken string
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			articleIDRaw := params["article_id"]
			v, err2 := strconv.ParseInt(articleIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("article_id", articleIDRaw, "integer"))
			}
			articleID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateArticlePayload(&body, articleID, sessionToken)

		return payload, nil
	}
}

// EncodeUpdateArticleError returns an encoder for errors returned by the
// UpdateArticle text endpoint.
func EncodeUpdateArticleError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "permission_denied":
			var res text.PermissionDenied
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteArticleResponse returns an encoder for responses returned by the
// text DeleteArticle endpoint.
func EncodeDeleteArticleResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*text.SimpleResponse)
		enc := encoder(ctx, w)
		body := NewDeleteArticleResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDeleteArticleRequest returns a decoder for requests sent to the text
// DeleteArticle endpoint.
func DecodeDeleteArticleRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			articleID    int64
			sessionToken string
			err          error
			c            *http.Cookie

			params = mux.Vars(r)
		)
		{
			articleIDRaw := params["article_id"]
			v, err2 := strconv.ParseInt(articleIDRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("article_id", articleIDRaw, "integer"))
			}
			articleID = v
		}
		c, err = r.Cookie("session")
		if err == http.ErrNoCookie {
			err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
		} else {
			sessionToken = c.Value
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteArticlePayload(articleID, sessionToken)

		return payload, nil
	}
}

// EncodeDeleteArticleError returns an encoder for errors returned by the
// DeleteArticle text endpoint.
func EncodeDeleteArticleError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "internal_error":
			var res text.InternalError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "invalid_input":
			var res text.InvalidInput
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res text.NotFound
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "permission_denied":
			var res text.PermissionDenied
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "service_unavailable":
			var res text.ServiceUnavailable
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "unauthorized":
			var res text.Unauthorized
			errors.As(v, &res)
			enc := encoder(ctx, w)
			body := res
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalTextCourseToCourseResponse builds a value of type *CourseResponse
// from a value of type *text.Course.
func marshalTextCourseToCourseResponse(v *text.Course) *CourseResponse {
	res := &CourseResponse{
		ID:          v.ID,
		Title:       v.Title,
		Description: v.Description,
		ImageURL:    v.ImageURL,
		CreatedAt:   v.CreatedAt,
		UpdatedAt:   v.UpdatedAt,
	}

	return res
}

// marshalTextSectionToSectionResponse builds a value of type *SectionResponse
// from a value of type *text.Section.
func marshalTextSectionToSectionResponse(v *text.Section) *SectionResponse {
	res := &SectionResponse{
		ID:          v.ID,
		CourseID:    v.CourseID,
		Title:       v.Title,
		Description: v.Description,
		Order:       v.Order,
		CreatedAt:   v.CreatedAt,
		UpdatedAt:   v.UpdatedAt,
	}

	return res
}

// marshalTextArticleToArticleResponse builds a value of type *ArticleResponse
// from a value of type *text.Article.
func marshalTextArticleToArticleResponse(v *text.Article) *ArticleResponse {
	res := &ArticleResponse{
		ID:        v.ID,
		SectionID: v.SectionID,
		Title:     v.Title,
		Content:   v.Content,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
	}

	return res
}
