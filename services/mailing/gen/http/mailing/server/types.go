// Code generated by goa v3.21.1, DO NOT EDIT.
//
// mailing HTTP server types
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/mailing/design/api
// -o ./services/mailing/

package server

import (
	"unicode/utf8"

	mailing "github.com/ynoacamino/infra-sustainable-classrooms/services/mailing/gen/mailing"
	goa "goa.design/goa/v3/pkg"
)

// SendEmailRequestBody is the type of the "mailing" service "SendEmail"
// endpoint HTTP request body.
type SendEmailRequestBody struct {
	// Email message to send
	Email *EmailMessageRequestBody `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
}

// SendEmailResponseBody is the type of the "mailing" service "SendEmail"
// endpoint HTTP response body.
type SendEmailResponseBody struct {
	// Whether the email was sent successfully
	Success bool `form:"success" json:"success" xml:"success"`
	// Response message
	Message string `form:"message" json:"message" xml:"message"`
	// Message ID from the SMTP server
	MessageID *string `form:"message_id,omitempty" json:"message_id,omitempty" xml:"message_id,omitempty"`
}

// EmailMessageRequestBody is used to define fields on request body types.
type EmailMessageRequestBody struct {
	// Recipient email addresses
	To []string `form:"to,omitempty" json:"to,omitempty" xml:"to,omitempty"`
	// Carbon copy email addresses
	Cc []string `form:"cc,omitempty" json:"cc,omitempty" xml:"cc,omitempty"`
	// Blind carbon copy email addresses
	Bcc []string `form:"bcc,omitempty" json:"bcc,omitempty" xml:"bcc,omitempty"`
	// Email subject
	Subject *string `form:"subject,omitempty" json:"subject,omitempty" xml:"subject,omitempty"`
	// Email body content
	Body *string `form:"body,omitempty" json:"body,omitempty" xml:"body,omitempty"`
	// Whether the body content is HTML
	IsHTML *bool `form:"is_html,omitempty" json:"is_html,omitempty" xml:"is_html,omitempty"`
}

// NewSendEmailResponseBody builds the HTTP response body from the result of
// the "SendEmail" endpoint of the "mailing" service.
func NewSendEmailResponseBody(res *mailing.EmailResponse) *SendEmailResponseBody {
	body := &SendEmailResponseBody{
		Success:   res.Success,
		Message:   res.Message,
		MessageID: res.MessageID,
	}
	return body
}

// NewSendEmailPayload builds a mailing service SendEmail endpoint payload.
func NewSendEmailPayload(body *SendEmailRequestBody) *mailing.SendEmailPayload {
	v := &mailing.SendEmailPayload{}
	v.Email = unmarshalEmailMessageRequestBodyToMailingEmailMessage(body.Email)

	return v
}

// ValidateSendEmailRequestBody runs the validations defined on
// SendEmailRequestBody
func ValidateSendEmailRequestBody(body *SendEmailRequestBody) (err error) {
	if body.Email == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("email", "body"))
	}
	if body.Email != nil {
		if err2 := ValidateEmailMessageRequestBody(body.Email); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateEmailMessageRequestBody runs the validations defined on
// EmailMessageRequestBody
func ValidateEmailMessageRequestBody(body *EmailMessageRequestBody) (err error) {
	if body.To == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("to", "body"))
	}
	if body.Subject == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("subject", "body"))
	}
	if body.Body == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("body", "body"))
	}
	if len(body.To) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.to", body.To, len(body.To), 1, true))
	}
	if body.Subject != nil {
		if utf8.RuneCountInString(*body.Subject) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.subject", *body.Subject, utf8.RuneCountInString(*body.Subject), 1, true))
		}
	}
	if body.Subject != nil {
		if utf8.RuneCountInString(*body.Subject) > 200 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.subject", *body.Subject, utf8.RuneCountInString(*body.Subject), 200, false))
		}
	}
	if body.Body != nil {
		if utf8.RuneCountInString(*body.Body) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.body", *body.Body, utf8.RuneCountInString(*body.Body), 1, true))
		}
	}
	return
}
