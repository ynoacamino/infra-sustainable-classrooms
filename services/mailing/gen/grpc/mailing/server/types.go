// Code generated by goa v3.21.1, DO NOT EDIT.
//
// mailing gRPC server types
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/mailing/design/api
// -o ./services/mailing/

package server

import (
	"unicode/utf8"

	mailingpb "github.com/ynoacamino/infra-sustainable-classrooms/services/mailing/gen/grpc/mailing/pb"
	mailing "github.com/ynoacamino/infra-sustainable-classrooms/services/mailing/gen/mailing"
	goa "goa.design/goa/v3/pkg"
)

// NewSendEmailPayload builds the payload of the "SendEmail" endpoint of the
// "mailing" service from the gRPC request type.
func NewSendEmailPayload(message *mailingpb.SendEmailRequest) *mailing.SendEmailPayload {
	v := &mailing.SendEmailPayload{}
	if message.Email != nil {
		v.Email = protobufMailingpbEmailMessageToMailingEmailMessage(message.Email)
	}
	return v
}

// NewProtoSendEmailResponse builds the gRPC response type from the result of
// the "SendEmail" endpoint of the "mailing" service.
func NewProtoSendEmailResponse(result *mailing.EmailResponse) *mailingpb.SendEmailResponse {
	message := &mailingpb.SendEmailResponse{
		Success:   result.Success,
		Message_:  result.Message,
		MessageId: result.MessageID,
	}
	return message
}

// ValidateSendEmailRequest runs the validations defined on SendEmailRequest.
func ValidateSendEmailRequest(message *mailingpb.SendEmailRequest) (err error) {
	if message.Email == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("email", "message"))
	}
	if message.Email != nil {
		if err2 := ValidateEmailMessage(message.Email); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateEmailMessage runs the validations defined on EmailMessage.
func ValidateEmailMessage(email *mailingpb.EmailMessage) (err error) {
	if email.To == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("to", "email"))
	}
	if len(email.To) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("email.to", email.To, len(email.To), 1, true))
	}
	if utf8.RuneCountInString(email.Subject) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("email.subject", email.Subject, utf8.RuneCountInString(email.Subject), 1, true))
	}
	if utf8.RuneCountInString(email.Subject) > 200 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("email.subject", email.Subject, utf8.RuneCountInString(email.Subject), 200, false))
	}
	if utf8.RuneCountInString(email.Body) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("email.body", email.Body, utf8.RuneCountInString(email.Body), 1, true))
	}
	return
}

// protobufMailingpbEmailMessageToMailingEmailMessage builds a value of type
// *mailing.EmailMessage from a value of type *mailingpb.EmailMessage.
func protobufMailingpbEmailMessageToMailingEmailMessage(v *mailingpb.EmailMessage) *mailing.EmailMessage {
	res := &mailing.EmailMessage{
		Subject: v.Subject,
		Body:    v.Body,
	}
	if v.IsHtml != nil {
		res.IsHTML = *v.IsHtml
	}
	if v.To != nil {
		res.To = make([]string, len(v.To))
		for i, val := range v.To {
			res.To[i] = val
		}
	}
	if v.Cc != nil {
		res.Cc = make([]string, len(v.Cc))
		for i, val := range v.Cc {
			res.Cc[i] = val
		}
	}
	if v.Bcc != nil {
		res.Bcc = make([]string, len(v.Bcc))
		for i, val := range v.Bcc {
			res.Bcc[i] = val
		}
	}
	if v.IsHtml == nil {
		res.IsHTML = false
	}

	return res
}

// svcMailingEmailMessageToMailingpbEmailMessage builds a value of type
// *mailingpb.EmailMessage from a value of type *mailing.EmailMessage.
func svcMailingEmailMessageToMailingpbEmailMessage(v *mailing.EmailMessage) *mailingpb.EmailMessage {
	res := &mailingpb.EmailMessage{
		Subject: v.Subject,
		Body:    v.Body,
		IsHtml:  &v.IsHTML,
	}
	if v.To != nil {
		res.To = make([]string, len(v.To))
		for i, val := range v.To {
			res.To[i] = val
		}
	}
	if v.Cc != nil {
		res.Cc = make([]string, len(v.Cc))
		for i, val := range v.Cc {
			res.Cc[i] = val
		}
	}
	if v.Bcc != nil {
		res.Bcc = make([]string, len(v.Bcc))
		for i, val := range v.Bcc {
			res.Bcc[i] = val
		}
	}

	return res
}
