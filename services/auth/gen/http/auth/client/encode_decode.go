// Code generated by goa v3.21.1, DO NOT EDIT.
//
// auth HTTP client encoders and decoders
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/auth/design/api
// -o ./services/auth/

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"

	auth "github.com/ynoacamino/infra-sustainable-classrooms/services/auth/gen/auth"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildGenerateSecretRequest instantiates a HTTP request object with method
// and path set to call the "auth" service "GenerateSecret" endpoint
func (c *Client) BuildGenerateSecretRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GenerateSecretAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "GenerateSecret", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGenerateSecretRequest returns an encoder for requests sent to the auth
// GenerateSecret server.
func EncodeGenerateSecretRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.GenerateSecretPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "GenerateSecret", "*auth.GenerateSecretPayload", v)
		}
		body := NewGenerateSecretRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "GenerateSecret", err)
		}
		return nil
	}
}

// DecodeGenerateSecretResponse returns a decoder for responses returned by the
// auth GenerateSecret endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeGenerateSecretResponse may return the following errors:
//   - "invalid_input" (type auth.InvalidInput): http.StatusBadRequest
//   - "service_unavailable" (type auth.ServiceUnavailable): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGenerateSecretResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GenerateSecretResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "GenerateSecret", err)
			}
			err = ValidateGenerateSecretResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "GenerateSecret", err)
			}
			res := NewGenerateSecretTOTPSecretOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "GenerateSecret", err)
			}
			return nil, NewGenerateSecretInvalidInput(body)
		case http.StatusServiceUnavailable:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "GenerateSecret", err)
			}
			return nil, NewGenerateSecretServiceUnavailable(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "GenerateSecret", resp.StatusCode, string(body))
		}
	}
}

// BuildVerifyTOTPRequest instantiates a HTTP request object with method and
// path set to call the "auth" service "VerifyTOTP" endpoint
func (c *Client) BuildVerifyTOTPRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: VerifyTOTPAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "VerifyTOTP", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeVerifyTOTPRequest returns an encoder for requests sent to the auth
// VerifyTOTP server.
func EncodeVerifyTOTPRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.VerifyTOTPPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "VerifyTOTP", "*auth.VerifyTOTPPayload", v)
		}
		body := NewVerifyTOTPRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "VerifyTOTP", err)
		}
		return nil
	}
}

// DecodeVerifyTOTPResponse returns a decoder for responses returned by the
// auth VerifyTOTP endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeVerifyTOTPResponse may return the following errors:
//   - "invalid_input" (type auth.InvalidInput): http.StatusBadRequest
//   - "invalid_otp" (type auth.InvalidOtp): http.StatusUnauthorized
//   - "user_not_found" (type auth.UserNotFound): http.StatusNotFound
//   - error: internal error
func DecodeVerifyTOTPResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body VerifyTOTPResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "VerifyTOTP", err)
			}
			err = ValidateVerifyTOTPResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "VerifyTOTP", err)
			}
			var (
				sessionToken    string
				sessionTokenRaw string

				cookies = resp.Cookies()
			)
			for _, c := range cookies {
				switch c.Name {
				case "session":
					sessionTokenRaw = c.Value
				}
			}
			if sessionTokenRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
			}
			sessionToken = sessionTokenRaw
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "VerifyTOTP", err)
			}
			res := NewVerifyTOTPAuthResponseOK(&body, sessionToken)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "VerifyTOTP", err)
			}
			return nil, NewVerifyTOTPInvalidInput(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "VerifyTOTP", err)
			}
			return nil, NewVerifyTOTPInvalidOtp(body)
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "VerifyTOTP", err)
			}
			return nil, NewVerifyTOTPUserNotFound(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "VerifyTOTP", resp.StatusCode, string(body))
		}
	}
}

// BuildVerifyBackupCodeRequest instantiates a HTTP request object with method
// and path set to call the "auth" service "VerifyBackupCode" endpoint
func (c *Client) BuildVerifyBackupCodeRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: VerifyBackupCodeAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "VerifyBackupCode", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeVerifyBackupCodeRequest returns an encoder for requests sent to the
// auth VerifyBackupCode server.
func EncodeVerifyBackupCodeRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.VerifyBackupCodePayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "VerifyBackupCode", "*auth.VerifyBackupCodePayload", v)
		}
		body := NewVerifyBackupCodeRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "VerifyBackupCode", err)
		}
		return nil
	}
}

// DecodeVerifyBackupCodeResponse returns a decoder for responses returned by
// the auth VerifyBackupCode endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeVerifyBackupCodeResponse may return the following errors:
//   - "invalid_input" (type auth.InvalidInput): http.StatusBadRequest
//   - "invalid_otp" (type auth.InvalidOtp): http.StatusUnauthorized
//   - "user_not_found" (type auth.UserNotFound): http.StatusNotFound
//   - error: internal error
func DecodeVerifyBackupCodeResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body VerifyBackupCodeResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "VerifyBackupCode", err)
			}
			err = ValidateVerifyBackupCodeResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "VerifyBackupCode", err)
			}
			var (
				sessionToken    string
				sessionTokenRaw string

				cookies = resp.Cookies()
			)
			for _, c := range cookies {
				switch c.Name {
				case "session":
					sessionTokenRaw = c.Value
				}
			}
			if sessionTokenRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("session_token", "cookie"))
			}
			sessionToken = sessionTokenRaw
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "VerifyBackupCode", err)
			}
			res := NewVerifyBackupCodeBackupCodeResponseOK(&body, sessionToken)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "VerifyBackupCode", err)
			}
			return nil, NewVerifyBackupCodeInvalidInput(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "VerifyBackupCode", err)
			}
			return nil, NewVerifyBackupCodeInvalidOtp(body)
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "VerifyBackupCode", err)
			}
			return nil, NewVerifyBackupCodeUserNotFound(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "VerifyBackupCode", resp.StatusCode, string(body))
		}
	}
}

// BuildRefreshSessionRequest instantiates a HTTP request object with method
// and path set to call the "auth" service "RefreshSession" endpoint
func (c *Client) BuildRefreshSessionRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RefreshSessionAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "RefreshSession", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRefreshSessionRequest returns an encoder for requests sent to the auth
// RefreshSession server.
func EncodeRefreshSessionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.RefreshSessionPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "RefreshSession", "*auth.RefreshSessionPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeRefreshSessionResponse returns a decoder for responses returned by the
// auth RefreshSession endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeRefreshSessionResponse may return the following errors:
//   - "unauthorized" (type auth.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeRefreshSessionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body RefreshSessionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "RefreshSession", err)
			}
			err = ValidateRefreshSessionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "RefreshSession", err)
			}
			var (
				sessionToken    *string
				sessionTokenRaw string

				cookies = resp.Cookies()
			)
			for _, c := range cookies {
				switch c.Name {
				case "session":
					sessionTokenRaw = c.Value
				}
			}
			if sessionTokenRaw != "" {
				sessionToken = &sessionTokenRaw
			}
			res := NewRefreshSessionSimpleResponseOK(&body, sessionToken)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "RefreshSession", err)
			}
			return nil, NewRefreshSessionUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "RefreshSession", resp.StatusCode, string(body))
		}
	}
}

// BuildLogoutRequest instantiates a HTTP request object with method and path
// set to call the "auth" service "Logout" endpoint
func (c *Client) BuildLogoutRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LogoutAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "Logout", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeLogoutRequest returns an encoder for requests sent to the auth Logout
// server.
func EncodeLogoutRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.LogoutPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "Logout", "*auth.LogoutPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeLogoutResponse returns a decoder for responses returned by the auth
// Logout endpoint. restoreBody controls whether the response body should be
// restored after having been read.
func DecodeLogoutResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body LogoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "Logout", err)
			}
			err = ValidateLogoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "Logout", err)
			}
			res := NewLogoutSimpleResponseOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "Logout", resp.StatusCode, string(body))
		}
	}
}

// BuildGetUserProfileRequest instantiates a HTTP request object with method
// and path set to call the "auth" service "GetUserProfile" endpoint
func (c *Client) BuildGetUserProfileRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetUserProfileAuthPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "GetUserProfile", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetUserProfileRequest returns an encoder for requests sent to the auth
// GetUserProfile server.
func EncodeGetUserProfileRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.GetUserProfilePayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "GetUserProfile", "*auth.GetUserProfilePayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeGetUserProfileResponse returns a decoder for responses returned by the
// auth GetUserProfile endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeGetUserProfileResponse may return the following errors:
//   - "unauthorized" (type auth.Unauthorized): http.StatusUnauthorized
//   - "user_not_found" (type auth.UserNotFound): http.StatusNotFound
//   - error: internal error
func DecodeGetUserProfileResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetUserProfileResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "GetUserProfile", err)
			}
			err = ValidateGetUserProfileResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "GetUserProfile", err)
			}
			res := NewGetUserProfileUserOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "GetUserProfile", err)
			}
			return nil, NewGetUserProfileUnauthorized(body)
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "GetUserProfile", err)
			}
			return nil, NewGetUserProfileUserNotFound(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "GetUserProfile", resp.StatusCode, string(body))
		}
	}
}

// marshalAuthDeviceInfoToDeviceInfoRequestBody builds a value of type
// *DeviceInfoRequestBody from a value of type *auth.DeviceInfo.
func marshalAuthDeviceInfoToDeviceInfoRequestBody(v *auth.DeviceInfo) *DeviceInfoRequestBody {
	if v == nil {
		return nil
	}
	res := &DeviceInfoRequestBody{
		UserAgent: v.UserAgent,
		IPAddress: v.IPAddress,
		DeviceID:  v.DeviceID,
		Platform:  v.Platform,
	}

	return res
}

// marshalDeviceInfoRequestBodyToAuthDeviceInfo builds a value of type
// *auth.DeviceInfo from a value of type *DeviceInfoRequestBody.
func marshalDeviceInfoRequestBodyToAuthDeviceInfo(v *DeviceInfoRequestBody) *auth.DeviceInfo {
	if v == nil {
		return nil
	}
	res := &auth.DeviceInfo{
		UserAgent: v.UserAgent,
		IPAddress: v.IPAddress,
		DeviceID:  v.DeviceID,
		Platform:  v.Platform,
	}

	return res
}

// unmarshalUserResponseBodyToAuthUser builds a value of type *auth.User from a
// value of type *UserResponseBody.
func unmarshalUserResponseBodyToAuthUser(v *UserResponseBody) *auth.User {
	res := &auth.User{
		ID:         *v.ID,
		Identifier: *v.Identifier,
		CreatedAt:  *v.CreatedAt,
		LastLogin:  v.LastLogin,
		IsVerified: *v.IsVerified,
	}
	if v.Metadata != nil {
		res.Metadata = make(map[string]string, len(v.Metadata))
		for key, val := range v.Metadata {
			tk := key
			tv := val
			res.Metadata[tk] = tv
		}
	}

	return res
}
