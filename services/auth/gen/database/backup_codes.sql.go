// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: backup_codes.sql

package authdb

import (
	"context"
)

const countAvailableBackupCodes = `-- name: CountAvailableBackupCodes :one
SELECT COUNT(*) FROM backup_codes
WHERE user_id = $1 
AND used_at IS NULL
`

func (q *Queries) CountAvailableBackupCodes(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countAvailableBackupCodes, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateBackupCodesParams struct {
	UserID   int64
	CodeHash string
}

const deleteUsedBackupCodes = `-- name: DeleteUsedBackupCodes :exec
DELETE FROM backup_codes
WHERE user_id = $1 
AND used_at IS NOT NULL
`

func (q *Queries) DeleteUsedBackupCodes(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteUsedBackupCodes, userID)
	return err
}

const deleteUserBackupCodes = `-- name: DeleteUserBackupCodes :exec
DELETE FROM backup_codes
WHERE user_id = $1
`

func (q *Queries) DeleteUserBackupCodes(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteUserBackupCodes, userID)
	return err
}

const getBackupCodeByHash = `-- name: GetBackupCodeByHash :one
SELECT id, user_id, code_hash, used_at, created_at FROM backup_codes
WHERE user_id = $1 
AND code_hash = $2 
AND used_at IS NULL
`

type GetBackupCodeByHashParams struct {
	UserID   int64
	CodeHash string
}

func (q *Queries) GetBackupCodeByHash(ctx context.Context, arg GetBackupCodeByHashParams) (BackupCode, error) {
	row := q.db.QueryRow(ctx, getBackupCodeByHash, arg.UserID, arg.CodeHash)
	var i BackupCode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CodeHash,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUsedBackupCodes = `-- name: GetUsedBackupCodes :many
SELECT id, user_id, code_hash, used_at, created_at FROM backup_codes
WHERE user_id = $1 
AND used_at IS NOT NULL
ORDER BY used_at DESC
`

func (q *Queries) GetUsedBackupCodes(ctx context.Context, userID int64) ([]BackupCode, error) {
	rows, err := q.db.Query(ctx, getUsedBackupCodes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupCode
	for rows.Next() {
		var i BackupCode
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CodeHash,
			&i.UsedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBackupCodes = `-- name: GetUserBackupCodes :many
SELECT id, user_id, code_hash, used_at, created_at FROM backup_codes
WHERE user_id = $1 
AND used_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) GetUserBackupCodes(ctx context.Context, userID int64) ([]BackupCode, error) {
	rows, err := q.db.Query(ctx, getUserBackupCodes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupCode
	for rows.Next() {
		var i BackupCode
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CodeHash,
			&i.UsedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const useBackupCode = `-- name: UseBackupCode :one
UPDATE backup_codes
SET used_at = NOW()
WHERE user_id = $1 
AND code_hash = $2 
AND used_at IS NULL
RETURNING id, user_id, code_hash, used_at, created_at
`

type UseBackupCodeParams struct {
	UserID   int64
	CodeHash string
}

func (q *Queries) UseBackupCode(ctx context.Context, arg UseBackupCodeParams) (BackupCode, error) {
	row := q.db.QueryRow(ctx, useBackupCode, arg.UserID, arg.CodeHash)
	var i BackupCode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CodeHash,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}
