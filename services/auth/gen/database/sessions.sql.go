// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sessions.sql

package authdb

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredSessions = `-- name: CleanupExpiredSessions :exec
UPDATE sessions 
SET is_active = false 
WHERE expires_at < NOW() 
AND is_active = true
`

func (q *Queries) CleanupExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredSessions)
	return err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    user_id,
    session_token,
    expires_at,
    user_agent,
    ip_address,
    device_id,
    platform
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, session_token, expires_at, created_at, last_accessed, is_active, user_agent, ip_address, device_id, platform
`

type CreateSessionParams struct {
	UserID       int64
	SessionToken string
	ExpiresAt    pgtype.Timestamptz
	UserAgent    pgtype.Text
	IpAddress    *netip.Addr
	DeviceID     pgtype.Text
	Platform     pgtype.Text
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.SessionToken,
		arg.ExpiresAt,
		arg.UserAgent,
		arg.IpAddress,
		arg.DeviceID,
		arg.Platform,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.LastAccessed,
		&i.IsActive,
		&i.UserAgent,
		&i.IpAddress,
		&i.DeviceID,
		&i.Platform,
	)
	return i, err
}

const deactivateAllUserSessionsExcept = `-- name: DeactivateAllUserSessionsExcept :exec
UPDATE sessions
SET is_active = false
WHERE user_id = $1 
AND session_token != $2 
AND is_active = true
`

type DeactivateAllUserSessionsExceptParams struct {
	UserID       int64
	SessionToken string
}

func (q *Queries) DeactivateAllUserSessionsExcept(ctx context.Context, arg DeactivateAllUserSessionsExceptParams) error {
	_, err := q.db.Exec(ctx, deactivateAllUserSessionsExcept, arg.UserID, arg.SessionToken)
	return err
}

const deactivateSession = `-- name: DeactivateSession :exec
UPDATE sessions
SET is_active = false
WHERE session_token = $1
`

func (q *Queries) DeactivateSession(ctx context.Context, sessionToken string) error {
	_, err := q.db.Exec(ctx, deactivateSession, sessionToken)
	return err
}

const deactivateUserSessions = `-- name: DeactivateUserSessions :exec
UPDATE sessions
SET is_active = false
WHERE user_id = $1 
AND is_active = true
`

func (q *Queries) DeactivateUserSessions(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deactivateUserSessions, userID)
	return err
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT s.id, s.user_id, s.session_token, s.expires_at, s.created_at, s.last_accessed, s.is_active, s.user_agent, s.ip_address, s.device_id, s.platform, u.identifier, u.is_verified
FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.session_token = $1 
AND s.is_active = true 
AND s.expires_at > NOW()
`

type GetSessionByTokenRow struct {
	ID           int64
	UserID       int64
	SessionToken string
	ExpiresAt    pgtype.Timestamptz
	CreatedAt    pgtype.Timestamptz
	LastAccessed pgtype.Timestamptz
	IsActive     bool
	UserAgent    pgtype.Text
	IpAddress    *netip.Addr
	DeviceID     pgtype.Text
	Platform     pgtype.Text
	Identifier   string
	IsVerified   bool
}

func (q *Queries) GetSessionByToken(ctx context.Context, sessionToken string) (GetSessionByTokenRow, error) {
	row := q.db.QueryRow(ctx, getSessionByToken, sessionToken)
	var i GetSessionByTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.LastAccessed,
		&i.IsActive,
		&i.UserAgent,
		&i.IpAddress,
		&i.DeviceID,
		&i.Platform,
		&i.Identifier,
		&i.IsVerified,
	)
	return i, err
}

const getSessionStats = `-- name: GetSessionStats :one
SELECT 
    COUNT(*) as total_sessions,
    COUNT(*) FILTER (WHERE is_active = true) as active_sessions,
    COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as sessions_last_24h
FROM sessions
`

type GetSessionStatsRow struct {
	TotalSessions   int64
	ActiveSessions  int64
	SessionsLast24h int64
}

func (q *Queries) GetSessionStats(ctx context.Context) (GetSessionStatsRow, error) {
	row := q.db.QueryRow(ctx, getSessionStats)
	var i GetSessionStatsRow
	err := row.Scan(&i.TotalSessions, &i.ActiveSessions, &i.SessionsLast24h)
	return i, err
}

const getUserSessions = `-- name: GetUserSessions :many
SELECT id, user_id, session_token, expires_at, created_at, last_accessed, is_active, user_agent, ip_address, device_id, platform FROM sessions
WHERE user_id = $1 
AND is_active = true 
AND expires_at > NOW()
ORDER BY last_accessed DESC
`

func (q *Queries) GetUserSessions(ctx context.Context, userID int64) ([]Session, error) {
	rows, err := q.db.Query(ctx, getUserSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionToken,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.LastAccessed,
			&i.IsActive,
			&i.UserAgent,
			&i.IpAddress,
			&i.DeviceID,
			&i.Platform,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshSession = `-- name: RefreshSession :one
UPDATE sessions
SET 
    expires_at = $2,
    last_accessed = NOW()
WHERE session_token = $1 
AND is_active = true
RETURNING id, user_id, session_token, expires_at, created_at, last_accessed, is_active, user_agent, ip_address, device_id, platform
`

type RefreshSessionParams struct {
	SessionToken string
	ExpiresAt    pgtype.Timestamptz
}

func (q *Queries) RefreshSession(ctx context.Context, arg RefreshSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, refreshSession, arg.SessionToken, arg.ExpiresAt)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.LastAccessed,
		&i.IsActive,
		&i.UserAgent,
		&i.IpAddress,
		&i.DeviceID,
		&i.Platform,
	)
	return i, err
}

const updateSessionAccess = `-- name: UpdateSessionAccess :exec
UPDATE sessions
SET last_accessed = NOW()
WHERE session_token = $1 
AND is_active = true
`

func (q *Queries) UpdateSessionAccess(ctx context.Context, sessionToken string) error {
	_, err := q.db.Exec(ctx, updateSessionAccess, sessionToken)
	return err
}
