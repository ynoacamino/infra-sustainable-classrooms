// Code generated by goa v3.21.1, DO NOT EDIT.
//
// auth gRPC server types
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/auth/design/api
// -o ./services/auth/

package server

import (
	auth "github.com/ynoacamino/infra-sustainable-classrooms/services/auth/gen/auth"
	authpb "github.com/ynoacamino/infra-sustainable-classrooms/services/auth/gen/grpc/auth/pb"
	goa "goa.design/goa/v3/pkg"
)

// NewValidateUserPayload builds the payload of the "ValidateUser" endpoint of
// the "auth" service from the gRPC request type.
func NewValidateUserPayload(message *authpb.ValidateUserRequest) *auth.ValidateUserPayload {
	v := &auth.ValidateUserPayload{
		SessionToken: message.SessionToken,
	}
	return v
}

// NewProtoValidateUserResponse builds the gRPC response type from the result
// of the "ValidateUser" endpoint of the "auth" service.
func NewProtoValidateUserResponse(result *auth.UserValidationResponse) *authpb.ValidateUserResponse {
	message := &authpb.ValidateUserResponse{
		Valid: result.Valid,
	}
	if result.User != nil {
		message.User = svcAuthUserToAuthpbUser(result.User)
	}
	if result.Session != nil {
		message.Session = svcAuthSessionToAuthpbSession(result.Session)
	}
	return message
}

// NewGetUserByIDPayload builds the payload of the "GetUserByID" endpoint of
// the "auth" service from the gRPC request type.
func NewGetUserByIDPayload(message *authpb.GetUserByIDRequest) *auth.GetUserByIDPayload {
	v := &auth.GetUserByIDPayload{
		UserID: message.UserId,
	}
	return v
}

// NewProtoGetUserByIDResponse builds the gRPC response type from the result of
// the "GetUserByID" endpoint of the "auth" service.
func NewProtoGetUserByIDResponse(result *auth.User) *authpb.GetUserByIDResponse {
	message := &authpb.GetUserByIDResponse{
		Id:         result.ID,
		Identifier: result.Identifier,
		CreatedAt:  result.CreatedAt,
		LastLogin:  result.LastLogin,
		IsVerified: result.IsVerified,
	}
	if result.Metadata != nil {
		message.Metadata = make(map[string]string, len(result.Metadata))
		for key, val := range result.Metadata {
			tk := key
			tv := val
			message.Metadata[tk] = tv
		}
	}
	return message
}

// ValidateGetUserByIDRequest runs the validations defined on
// GetUserByIDRequest.
func ValidateGetUserByIDRequest(message *authpb.GetUserByIDRequest) (err error) {
	if message.UserId < 1 {
		err = goa.MergeErrors(err, goa.InvalidRangeError("message.user_id", message.UserId, 1, true))
	}
	return
}

// svcAuthUserToAuthpbUser builds a value of type *authpb.User from a value of
// type *auth.User.
func svcAuthUserToAuthpbUser(v *auth.User) *authpb.User {
	if v == nil {
		return nil
	}
	res := &authpb.User{
		Id:         v.ID,
		Identifier: v.Identifier,
		CreatedAt:  v.CreatedAt,
		LastLogin:  v.LastLogin,
		IsVerified: v.IsVerified,
	}
	if v.Metadata != nil {
		res.Metadata = make(map[string]string, len(v.Metadata))
		for key, val := range v.Metadata {
			tk := key
			tv := val
			res.Metadata[tk] = tv
		}
	}

	return res
}

// svcAuthSessionToAuthpbSession builds a value of type *authpb.Session from a
// value of type *auth.Session.
func svcAuthSessionToAuthpbSession(v *auth.Session) *authpb.Session {
	if v == nil {
		return nil
	}
	res := &authpb.Session{
		Id:           v.ID,
		UserId:       v.UserID,
		CreatedAt:    v.CreatedAt,
		ExpiresAt:    v.ExpiresAt,
		LastAccessed: v.LastAccessed,
		IsActive:     v.IsActive,
		UserAgent:    v.UserAgent,
		IpAddress:    v.IPAddress,
		DeviceId:     v.DeviceID,
		Platform:     v.Platform,
	}

	return res
}

// protobufAuthpbUserToAuthUser builds a value of type *auth.User from a value
// of type *authpb.User.
func protobufAuthpbUserToAuthUser(v *authpb.User) *auth.User {
	if v == nil {
		return nil
	}
	res := &auth.User{
		ID:         v.Id,
		Identifier: v.Identifier,
		CreatedAt:  v.CreatedAt,
		LastLogin:  v.LastLogin,
		IsVerified: v.IsVerified,
	}
	if v.Metadata != nil {
		res.Metadata = make(map[string]string, len(v.Metadata))
		for key, val := range v.Metadata {
			tk := key
			tv := val
			res.Metadata[tk] = tv
		}
	}

	return res
}

// protobufAuthpbSessionToAuthSession builds a value of type *auth.Session from
// a value of type *authpb.Session.
func protobufAuthpbSessionToAuthSession(v *authpb.Session) *auth.Session {
	if v == nil {
		return nil
	}
	res := &auth.Session{
		ID:           v.Id,
		UserID:       v.UserId,
		CreatedAt:    v.CreatedAt,
		ExpiresAt:    v.ExpiresAt,
		LastAccessed: v.LastAccessed,
		IsActive:     v.IsActive,
		UserAgent:    v.UserAgent,
		IPAddress:    v.IpAddress,
		DeviceID:     v.DeviceId,
		Platform:     v.Platform,
	}

	return res
}
