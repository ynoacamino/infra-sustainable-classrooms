// Code generated by goa v3.21.1, DO NOT EDIT.
//
// auth gRPC client types
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/auth/design/api
// -o ./services/auth/

package client

import (
	auth "github.com/ynoacamino/infra-sustainable-classrooms/services/auth/gen/auth"
	authpb "github.com/ynoacamino/infra-sustainable-classrooms/services/auth/gen/grpc/auth/pb"
)

// NewProtoValidateUserRequest builds the gRPC request type from the payload of
// the "ValidateUser" endpoint of the "auth" service.
func NewProtoValidateUserRequest(payload *auth.ValidateUserPayload) *authpb.ValidateUserRequest {
	message := &authpb.ValidateUserRequest{
		SessionToken: payload.SessionToken,
	}
	return message
}

// NewValidateUserResult builds the result type of the "ValidateUser" endpoint
// of the "auth" service from the gRPC response type.
func NewValidateUserResult(message *authpb.ValidateUserResponse) *auth.UserValidationResponse {
	result := &auth.UserValidationResponse{
		Valid: message.Valid,
	}
	if message.User != nil {
		result.User = protobufAuthpbUserToAuthUser(message.User)
	}
	if message.Session != nil {
		result.Session = protobufAuthpbSessionToAuthSession(message.Session)
	}
	return result
}

// NewProtoGetUserByIDRequest builds the gRPC request type from the payload of
// the "GetUserByID" endpoint of the "auth" service.
func NewProtoGetUserByIDRequest(payload *auth.GetUserByIDPayload) *authpb.GetUserByIDRequest {
	message := &authpb.GetUserByIDRequest{
		UserId: payload.UserID,
	}
	return message
}

// NewGetUserByIDResult builds the result type of the "GetUserByID" endpoint of
// the "auth" service from the gRPC response type.
func NewGetUserByIDResult(message *authpb.GetUserByIDResponse) *auth.User {
	result := &auth.User{
		ID:         message.Id,
		Identifier: message.Identifier,
		CreatedAt:  message.CreatedAt,
		LastLogin:  message.LastLogin,
		IsVerified: message.IsVerified,
	}
	if message.Metadata != nil {
		result.Metadata = make(map[string]string, len(message.Metadata))
		for key, val := range message.Metadata {
			tk := key
			tv := val
			result.Metadata[tk] = tv
		}
	}
	return result
}

// svcAuthUserToAuthpbUser builds a value of type *authpb.User from a value of
// type *auth.User.
func svcAuthUserToAuthpbUser(v *auth.User) *authpb.User {
	if v == nil {
		return nil
	}
	res := &authpb.User{
		Id:         v.ID,
		Identifier: v.Identifier,
		CreatedAt:  v.CreatedAt,
		LastLogin:  v.LastLogin,
		IsVerified: v.IsVerified,
	}
	if v.Metadata != nil {
		res.Metadata = make(map[string]string, len(v.Metadata))
		for key, val := range v.Metadata {
			tk := key
			tv := val
			res.Metadata[tk] = tv
		}
	}

	return res
}

// svcAuthSessionToAuthpbSession builds a value of type *authpb.Session from a
// value of type *auth.Session.
func svcAuthSessionToAuthpbSession(v *auth.Session) *authpb.Session {
	if v == nil {
		return nil
	}
	res := &authpb.Session{
		Id:           v.ID,
		UserId:       v.UserID,
		CreatedAt:    v.CreatedAt,
		ExpiresAt:    v.ExpiresAt,
		LastAccessed: v.LastAccessed,
		IsActive:     v.IsActive,
		UserAgent:    v.UserAgent,
		IpAddress:    v.IPAddress,
		DeviceId:     v.DeviceID,
		Platform:     v.Platform,
	}

	return res
}

// protobufAuthpbUserToAuthUser builds a value of type *auth.User from a value
// of type *authpb.User.
func protobufAuthpbUserToAuthUser(v *authpb.User) *auth.User {
	if v == nil {
		return nil
	}
	res := &auth.User{
		ID:         v.Id,
		Identifier: v.Identifier,
		CreatedAt:  v.CreatedAt,
		LastLogin:  v.LastLogin,
		IsVerified: v.IsVerified,
	}
	if v.Metadata != nil {
		res.Metadata = make(map[string]string, len(v.Metadata))
		for key, val := range v.Metadata {
			tk := key
			tv := val
			res.Metadata[tk] = tv
		}
	}

	return res
}

// protobufAuthpbSessionToAuthSession builds a value of type *auth.Session from
// a value of type *authpb.Session.
func protobufAuthpbSessionToAuthSession(v *authpb.Session) *auth.Session {
	if v == nil {
		return nil
	}
	res := &auth.Session{
		ID:           v.Id,
		UserID:       v.UserId,
		CreatedAt:    v.CreatedAt,
		ExpiresAt:    v.ExpiresAt,
		LastAccessed: v.LastAccessed,
		IsActive:     v.IsActive,
		UserAgent:    v.UserAgent,
		IPAddress:    v.IpAddress,
		DeviceID:     v.DeviceId,
		Platform:     v.Platform,
	}

	return res
}
