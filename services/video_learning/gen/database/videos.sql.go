// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: videos.sql

package video_learningdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignTagToVideo = `-- name: AssignTagToVideo :exec
INSERT INTO
    video_video_tags (video_id, tag_id)
VALUES ($1, $2)
ON CONFLICT (video_id, tag_id) DO NOTHING
`

type AssignTagToVideoParams struct {
	VideoID int64
	TagID   int64
}

func (q *Queries) AssignTagToVideo(ctx context.Context, arg AssignTagToVideoParams) error {
	_, err := q.db.Exec(ctx, assignTagToVideo, arg.VideoID, arg.TagID)
	return err
}

const createVideo = `-- name: CreateVideo :one
INSERT INTO
    video (
        title,
        user_id,
        description,
        views,
        likes,
        video_obj_name,
        thumb_obj_name,
        category_id
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    )
RETURNING
    id, title, user_id, description, views, likes, video_obj_name, thumb_obj_name, category_id, created_at, updated_at
`

type CreateVideoParams struct {
	Title        string
	UserID       int64
	Description  pgtype.Text
	Views        int32
	Likes        int32
	VideoObjName pgtype.Text
	ThumbObjName pgtype.Text
	CategoryID   int64
}

func (q *Queries) CreateVideo(ctx context.Context, arg CreateVideoParams) (Video, error) {
	row := q.db.QueryRow(ctx, createVideo,
		arg.Title,
		arg.UserID,
		arg.Description,
		arg.Views,
		arg.Likes,
		arg.VideoObjName,
		arg.ThumbObjName,
		arg.CategoryID,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.UserID,
		&i.Description,
		&i.Views,
		&i.Likes,
		&i.VideoObjName,
		&i.ThumbObjName,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVideo = `-- name: DeleteVideo :exec
DELETE FROM video WHERE id = $1
`

func (q *Queries) DeleteVideo(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteVideo, id)
	return err
}

const getRecentVideos = `-- name: GetRecentVideos :many
SELECT v.id, v.title, v.user_id, v.description, v.views, v.likes, v.video_obj_name, v.thumb_obj_name, v.category_id, v.created_at, v.updated_at
FROM video v
WHERE
    v.created_at >= NOW() - ($1)::interval
`

func (q *Queries) GetRecentVideos(ctx context.Context, dollar_1 pgtype.Interval) ([]Video, error) {
	rows, err := q.db.Query(ctx, getRecentVideos, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.UserID,
			&i.Description,
			&i.Views,
			&i.Likes,
			&i.VideoObjName,
			&i.ThumbObjName,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarVideos = `-- name: GetSimilarVideos :many
SELECT v.id, v.title, v.user_id, v.description, v.views, v.likes, v.video_obj_name, v.thumb_obj_name, v.category_id, v.created_at, v.updated_at
FROM video v
WHERE
    v.id != $1
    AND v.category_id = (
        SELECT category_id
        FROM video
        WHERE
            id = $1
    )
`

func (q *Queries) GetSimilarVideos(ctx context.Context, id int64) ([]Video, error) {
	rows, err := q.db.Query(ctx, getSimilarVideos, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.UserID,
			&i.Description,
			&i.Views,
			&i.Likes,
			&i.VideoObjName,
			&i.ThumbObjName,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideoByID = `-- name: GetVideoByID :one
SELECT v.id, v.title, v.user_id, v.description, v.views, v.likes, v.video_obj_name, v.thumb_obj_name, v.category_id, v.created_at, v.updated_at FROM video v WHERE v.id = $1
`

func (q *Queries) GetVideoByID(ctx context.Context, id int64) (Video, error) {
	row := q.db.QueryRow(ctx, getVideoByID, id)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.UserID,
		&i.Description,
		&i.Views,
		&i.Likes,
		&i.VideoObjName,
		&i.ThumbObjName,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVideosByCategory = `-- name: GetVideosByCategory :many
SELECT v.id, v.title, v.user_id, v.description, v.views, v.likes, v.video_obj_name, v.thumb_obj_name, v.category_id, v.created_at, v.updated_at FROM video v WHERE v.category_id = $1
`

func (q *Queries) GetVideosByCategory(ctx context.Context, categoryID int64) ([]Video, error) {
	rows, err := q.db.Query(ctx, getVideosByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.UserID,
			&i.Description,
			&i.Views,
			&i.Likes,
			&i.VideoObjName,
			&i.ThumbObjName,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideosByUser = `-- name: GetVideosByUser :many
SELECT v.id, v.title, v.user_id, v.description, v.views, v.likes, v.video_obj_name, v.thumb_obj_name, v.category_id, v.created_at, v.updated_at
FROM video v
WHERE
    v.user_id = $1
ORDER BY v.created_at DESC
LIMIT $2
OFFSET
    $3
`

type GetVideosByUserParams struct {
	UserID int64
	Limit  int32
	Offset int32
}

func (q *Queries) GetVideosByUser(ctx context.Context, arg GetVideosByUserParams) ([]Video, error) {
	rows, err := q.db.Query(ctx, getVideosByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.UserID,
			&i.Description,
			&i.Views,
			&i.Likes,
			&i.VideoObjName,
			&i.ThumbObjName,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementVideoLikes = `-- name: IncrementVideoLikes :exec
UPDATE video SET likes = likes + $2 WHERE id = $1
`

type IncrementVideoLikesParams struct {
	ID    int64
	Likes int32
}

func (q *Queries) IncrementVideoLikes(ctx context.Context, arg IncrementVideoLikesParams) error {
	_, err := q.db.Exec(ctx, incrementVideoLikes, arg.ID, arg.Likes)
	return err
}

const incrementVideoViews = `-- name: IncrementVideoViews :exec
UPDATE video SET views = views + $2 WHERE id = $1
`

type IncrementVideoViewsParams struct {
	ID    int64
	Views int32
}

func (q *Queries) IncrementVideoViews(ctx context.Context, arg IncrementVideoViewsParams) error {
	_, err := q.db.Exec(ctx, incrementVideoViews, arg.ID, arg.Views)
	return err
}

const removeTagFromVideo = `-- name: RemoveTagFromVideo :exec
DELETE FROM video_video_tags WHERE video_id = $1 AND tag_id = $2
`

type RemoveTagFromVideoParams struct {
	VideoID int64
	TagID   int64
}

func (q *Queries) RemoveTagFromVideo(ctx context.Context, arg RemoveTagFromVideoParams) error {
	_, err := q.db.Exec(ctx, removeTagFromVideo, arg.VideoID, arg.TagID)
	return err
}

const searchVideos = `-- name: SearchVideos :many
SELECT DISTINCT
    v.id, v.title, v.user_id, v.description, v.views, v.likes, v.video_obj_name, v.thumb_obj_name, v.category_id, v.created_at, v.updated_at
FROM
    video v
    LEFT JOIN video_video_tags vvt ON v.id = vvt.video_id
    LEFT JOIN video_tags vt ON vvt.tag_id = vt.id
WHERE (
        v.title ILIKE '%' || $1 || '%'
        OR vt.name ILIKE '%' || $1 || '%'
    )
    AND (
        $2::bigint = 0
        OR v.category_id = $2
    )
LIMIT $3
OFFSET
    $4
`

type SearchVideosParams struct {
	Column1 pgtype.Text
	Column2 int64
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchVideos(ctx context.Context, arg SearchVideosParams) ([]Video, error) {
	rows, err := q.db.Query(ctx, searchVideos,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.UserID,
			&i.Description,
			&i.Views,
			&i.Likes,
			&i.VideoObjName,
			&i.ThumbObjName,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
