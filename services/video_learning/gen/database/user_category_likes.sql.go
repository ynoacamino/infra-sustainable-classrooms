// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_category_likes.sql

package video_learningdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAllUserCategoryLikes = `-- name: DeleteAllUserCategoryLikes :exec
DELETE FROM user_category_likes WHERE user_id = $1
`

func (q *Queries) DeleteAllUserCategoryLikes(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteAllUserCategoryLikes, userID)
	return err
}

const getUserCategoryLikes = `-- name: GetUserCategoryLikes :many
SELECT vc.name, ucl.likes
FROM
    video_categories vc
    LEFT JOIN user_category_likes ucl ON vc.id = ucl.category_id
WHERE
    ucl.user_id = $1
`

type GetUserCategoryLikesRow struct {
	Name  string
	Likes pgtype.Int4
}

func (q *Queries) GetUserCategoryLikes(ctx context.Context, userID int64) ([]GetUserCategoryLikesRow, error) {
	rows, err := q.db.Query(ctx, getUserCategoryLikes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserCategoryLikesRow
	for rows.Next() {
		var i GetUserCategoryLikesRow
		if err := rows.Scan(&i.Name, &i.Likes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserVideoLike = `-- name: GetUserVideoLike :one
SELECT user_id, video_id, liked, created_at, updated_at
FROM user_video_likes
WHERE
    user_id = $1
    AND video_id = $2
`

type GetUserVideoLikeParams struct {
	UserID  int64
	VideoID int64
}

func (q *Queries) GetUserVideoLike(ctx context.Context, arg GetUserVideoLikeParams) (UserVideoLike, error) {
	row := q.db.QueryRow(ctx, getUserVideoLike, arg.UserID, arg.VideoID)
	var i UserVideoLike
	err := row.Scan(
		&i.UserID,
		&i.VideoID,
		&i.Liked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementUserCategoryLike = `-- name: IncrementUserCategoryLike :exec
INSERT INTO
    user_category_likes (user_id, category_id, likes)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, category_id) DO
UPDATE
SET
    likes = user_category_likes.likes + $3
`

type IncrementUserCategoryLikeParams struct {
	UserID     int64
	CategoryID int64
	Likes      int32
}

func (q *Queries) IncrementUserCategoryLike(ctx context.Context, arg IncrementUserCategoryLikeParams) error {
	_, err := q.db.Exec(ctx, incrementUserCategoryLike, arg.UserID, arg.CategoryID, arg.Likes)
	return err
}

const upsertUserCategoryLike = `-- name: UpsertUserCategoryLike :exec
INSERT INTO user_category_likes (user_id, category_id, likes)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, category_id) DO UPDATE
SET likes = likes + $3, updated_at = NOW()
`

type UpsertUserCategoryLikeParams struct {
	UserID     int64
	CategoryID int64
	Likes      int32
}

func (q *Queries) UpsertUserCategoryLike(ctx context.Context, arg UpsertUserCategoryLikeParams) error {
	_, err := q.db.Exec(ctx, upsertUserCategoryLike, arg.UserID, arg.CategoryID, arg.Likes)
	return err
}

const upsertUserVideoLike = `-- name: UpsertUserVideoLike :exec
INSERT INTO user_video_likes (user_id, video_id, liked)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, video_id) DO UPDATE
SET liked = $3, updated_at = NOW()
`

type UpsertUserVideoLikeParams struct {
	UserID  int64
	VideoID int64
	Liked   bool
}

func (q *Queries) UpsertUserVideoLike(ctx context.Context, arg UpsertUserVideoLikeParams) error {
	_, err := q.db.Exec(ctx, upsertUserVideoLike, arg.UserID, arg.VideoID, arg.Liked)
	return err
}
