// Code generated by goa v3.21.1, DO NOT EDIT.
//
// video_learning HTTP client encoders and decoders
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/video_learning/design/api
// -o ./services/video_learning/

package client

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"

	videolearning "github.com/ynoacamino/infra-sustainable-classrooms/services/video_learning/gen/video_learning"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildSearchVideosRequest instantiates a HTTP request object with method and
// path set to call the "video_learning" service "SearchVideos" endpoint
func (c *Client) BuildSearchVideosRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SearchVideosVideoLearningPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "SearchVideos", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSearchVideosRequest returns an encoder for requests sent to the
// video_learning SearchVideos server.
func EncodeSearchVideosRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.SearchVideosPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "SearchVideos", "*videolearning.SearchVideosPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		values := req.URL.Query()
		values.Add("query", p.Query)
		if p.CategoryID != nil {
			values.Add("category_id", fmt.Sprintf("%v", *p.CategoryID))
		}
		values.Add("page", fmt.Sprintf("%v", p.Page))
		values.Add("page_size", fmt.Sprintf("%v", p.PageSize))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeSearchVideosResponse returns a decoder for responses returned by the
// video_learning SearchVideos endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeSearchVideosResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "service_unavailable" (type videolearning.ServiceUnavailable): http.StatusServiceUnavailable
//   - error: internal error
func DecodeSearchVideosResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body SearchVideosResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "SearchVideos", err)
			}
			err = ValidateSearchVideosResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "SearchVideos", err)
			}
			res := NewSearchVideosVideoListOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "SearchVideos", err)
			}
			return nil, NewSearchVideosInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "SearchVideos", err)
				}
				return nil, NewSearchVideosInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "SearchVideos", err)
				}
				return nil, NewSearchVideosUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "SearchVideos", resp.StatusCode, string(body))
			}
		case http.StatusServiceUnavailable:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "SearchVideos", err)
			}
			return nil, NewSearchVideosServiceUnavailable(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "SearchVideos", resp.StatusCode, string(body))
		}
	}
}

// BuildGetRecommendationsRequest instantiates a HTTP request object with
// method and path set to call the "video_learning" service
// "GetRecommendations" endpoint
func (c *Client) BuildGetRecommendationsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetRecommendationsVideoLearningPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetRecommendations", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetRecommendationsRequest returns an encoder for requests sent to the
// video_learning GetRecommendations server.
func EncodeGetRecommendationsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetRecommendationsPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetRecommendations", "*videolearning.GetRecommendationsPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		values := req.URL.Query()
		values.Add("amount", fmt.Sprintf("%v", p.Amount))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetRecommendationsResponse returns a decoder for responses returned by
// the video_learning GetRecommendations endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeGetRecommendationsResponse may return the following errors:
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "service_unavailable" (type videolearning.ServiceUnavailable): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetRecommendationsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetRecommendationsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetRecommendations", err)
			}
			err = ValidateGetRecommendationsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetRecommendations", err)
			}
			res := NewGetRecommendationsVideoListOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetRecommendations", err)
				}
				return nil, NewGetRecommendationsInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetRecommendations", err)
				}
				return nil, NewGetRecommendationsUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetRecommendations", resp.StatusCode, string(body))
			}
		case http.StatusServiceUnavailable:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetRecommendations", err)
			}
			return nil, NewGetRecommendationsServiceUnavailable(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetRecommendations", resp.StatusCode, string(body))
		}
	}
}

// BuildGetVideoRequest instantiates a HTTP request object with method and path
// set to call the "video_learning" service "GetVideo" endpoint
func (c *Client) BuildGetVideoRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		videoID int64
	)
	{
		p, ok := v.(*videolearning.GetVideoPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "GetVideo", "*videolearning.GetVideoPayload", v)
		}
		videoID = p.VideoID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetVideoVideoLearningPath(videoID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetVideo", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetVideoRequest returns an encoder for requests sent to the
// video_learning GetVideo server.
func EncodeGetVideoRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetVideoPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetVideo", "*videolearning.GetVideoPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeGetVideoResponse returns a decoder for responses returned by the
// video_learning GetVideo endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeGetVideoResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "video_not_found" (type videolearning.VideoNotFound): http.StatusNotFound
//   - error: internal error
func DecodeGetVideoResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetVideoResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetVideo", err)
			}
			err = ValidateGetVideoResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetVideo", err)
			}
			res := NewGetVideoVideoDetailsOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetVideo", err)
			}
			return nil, NewGetVideoInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetVideo", err)
				}
				return nil, NewGetVideoInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetVideo", err)
				}
				return nil, NewGetVideoUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetVideo", resp.StatusCode, string(body))
			}
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetVideo", err)
			}
			return nil, NewGetVideoVideoNotFound(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetVideo", resp.StatusCode, string(body))
		}
	}
}

// BuildGetCommentsRequest instantiates a HTTP request object with method and
// path set to call the "video_learning" service "GetComments" endpoint
func (c *Client) BuildGetCommentsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		videoID int64
	)
	{
		p, ok := v.(*videolearning.GetCommentsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "GetComments", "*videolearning.GetCommentsPayload", v)
		}
		videoID = p.VideoID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetCommentsVideoLearningPath(videoID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetComments", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetCommentsRequest returns an encoder for requests sent to the
// video_learning GetComments server.
func EncodeGetCommentsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetCommentsPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetComments", "*videolearning.GetCommentsPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		values := req.URL.Query()
		values.Add("page", fmt.Sprintf("%v", p.Page))
		values.Add("page_size", fmt.Sprintf("%v", p.PageSize))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetCommentsResponse returns a decoder for responses returned by the
// video_learning GetComments endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetCommentsResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "video_not_found" (type videolearning.VideoNotFound): http.StatusNotFound
//   - error: internal error
func DecodeGetCommentsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetCommentsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetComments", err)
			}
			err = ValidateGetCommentsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetComments", err)
			}
			res := NewGetCommentsCommentListOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetComments", err)
			}
			return nil, NewGetCommentsInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetComments", err)
				}
				return nil, NewGetCommentsInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetComments", err)
				}
				return nil, NewGetCommentsUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetComments", resp.StatusCode, string(body))
			}
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetComments", err)
			}
			return nil, NewGetCommentsVideoNotFound(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetComments", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateCommentRequest instantiates a HTTP request object with method and
// path set to call the "video_learning" service "CreateComment" endpoint
func (c *Client) BuildCreateCommentRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		videoID int64
	)
	{
		p, ok := v.(*videolearning.CreateCommentPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "CreateComment", "*videolearning.CreateCommentPayload", v)
		}
		videoID = p.VideoID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateCommentVideoLearningPath(videoID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "CreateComment", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateCommentRequest returns an encoder for requests sent to the
// video_learning CreateComment server.
func EncodeCreateCommentRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.CreateCommentPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "CreateComment", "*videolearning.CreateCommentPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		body := NewCreateCommentRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("video_learning", "CreateComment", err)
		}
		return nil
	}
}

// DecodeCreateCommentResponse returns a decoder for responses returned by the
// video_learning CreateComment endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCreateCommentResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "video_not_found" (type videolearning.VideoNotFound): http.StatusNotFound
//   - error: internal error
func DecodeCreateCommentResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateCommentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "CreateComment", err)
			}
			err = ValidateCreateCommentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "CreateComment", err)
			}
			res := NewCreateCommentSimpleResponseCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "CreateComment", err)
			}
			return nil, NewCreateCommentInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "CreateComment", err)
				}
				return nil, NewCreateCommentInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "CreateComment", err)
				}
				return nil, NewCreateCommentUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "CreateComment", resp.StatusCode, string(body))
			}
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "CreateComment", err)
			}
			return nil, NewCreateCommentVideoNotFound(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "CreateComment", resp.StatusCode, string(body))
		}
	}
}

// BuildGetOwnVideosRequest instantiates a HTTP request object with method and
// path set to call the "video_learning" service "GetOwnVideos" endpoint
func (c *Client) BuildGetOwnVideosRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetOwnVideosVideoLearningPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetOwnVideos", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetOwnVideosRequest returns an encoder for requests sent to the
// video_learning GetOwnVideos server.
func EncodeGetOwnVideosRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetOwnVideosPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetOwnVideos", "*videolearning.GetOwnVideosPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		values := req.URL.Query()
		values.Add("page", fmt.Sprintf("%v", p.Page))
		values.Add("page_size", fmt.Sprintf("%v", p.PageSize))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetOwnVideosResponse returns a decoder for responses returned by the
// video_learning GetOwnVideos endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetOwnVideosResponse may return the following errors:
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeGetOwnVideosResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetOwnVideosResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetOwnVideos", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateOwnVideoResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetOwnVideos", err)
			}
			res := NewGetOwnVideosOwnVideoOK(body)
			return res, nil
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetOwnVideos", err)
				}
				return nil, NewGetOwnVideosInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetOwnVideos", err)
				}
				return nil, NewGetOwnVideosUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetOwnVideos", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetOwnVideos", resp.StatusCode, string(body))
		}
	}
}

// BuildInitialUploadRequest instantiates a HTTP request object with method and
// path set to call the "video_learning" service "InitialUpload" endpoint
func (c *Client) BuildInitialUploadRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		filename string
		body     io.Reader
	)
	{
		rd, ok := v.(*videolearning.InitialUploadRequestData)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "InitialUpload", "videolearning.InitialUploadRequestData", v)
		}
		p := rd.Payload
		body = rd.Body
		filename = p.Filename
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: InitialUploadVideoLearningPath(filename)}
	req, err := http.NewRequest("POST", u.String(), body)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "InitialUpload", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeInitialUploadRequest returns an encoder for requests sent to the
// video_learning InitialUpload server.
func EncodeInitialUploadRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		data, ok := v.(*videolearning.InitialUploadRequestData)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "InitialUpload", "*videolearning.InitialUploadRequestData", v)
		}
		p := data.Payload
		{
			head := p.ContentType
			req.Header.Set("Content-Type", head)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeInitialUploadResponse returns a decoder for responses returned by the
// video_learning InitialUpload endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeInitialUploadResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "upload_failed" (type videolearning.UploadFailed): http.StatusInternalServerError
//   - error: internal error
func DecodeInitialUploadResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body InitialUploadResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "InitialUpload", err)
			}
			err = ValidateInitialUploadResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "InitialUpload", err)
			}
			res := NewInitialUploadUploadResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "InitialUpload", err)
			}
			return nil, NewInitialUploadInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "InitialUpload", err)
				}
				return nil, NewInitialUploadInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "InitialUpload", err)
				}
				return nil, NewInitialUploadUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "InitialUpload", resp.StatusCode, string(body))
			}
		case http.StatusInternalServerError:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "InitialUpload", err)
			}
			return nil, NewInitialUploadUploadFailed(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "InitialUpload", resp.StatusCode, string(body))
		}
	}
}

// // BuildInitialUploadStreamPayload creates a streaming endpoint request payload
// from the method payload and the path to the file to be streamed
func BuildInitialUploadStreamPayload(payload any, fpath string) (*videolearning.InitialUploadRequestData, error) {
	f, err := os.Open(fpath)
	if err != nil {
		return nil, err
	}
	return &videolearning.InitialUploadRequestData{
		Payload: payload.(*videolearning.InitialUploadPayload),
		Body:    f,
	}, nil
}

// BuildCompleteUploadRequest instantiates a HTTP request object with method
// and path set to call the "video_learning" service "CompleteUpload" endpoint
func (c *Client) BuildCompleteUploadRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CompleteUploadVideoLearningPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "CompleteUpload", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCompleteUploadRequest returns an encoder for requests sent to the
// video_learning CompleteUpload server.
func EncodeCompleteUploadRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.CompleteUploadPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "CompleteUpload", "*videolearning.CompleteUploadPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		body := NewCompleteUploadRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("video_learning", "CompleteUpload", err)
		}
		return nil
	}
}

// DecodeCompleteUploadResponse returns a decoder for responses returned by the
// video_learning CompleteUpload endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCompleteUploadResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeCompleteUploadResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CompleteUploadResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "CompleteUpload", err)
			}
			err = ValidateCompleteUploadResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "CompleteUpload", err)
			}
			res := NewCompleteUploadSimpleResponseCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "CompleteUpload", err)
			}
			return nil, NewCompleteUploadInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "CompleteUpload", err)
				}
				return nil, NewCompleteUploadInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "CompleteUpload", err)
				}
				return nil, NewCompleteUploadUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "CompleteUpload", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "CompleteUpload", resp.StatusCode, string(body))
		}
	}
}

// BuildUploadThumbnailRequest instantiates a HTTP request object with method
// and path set to call the "video_learning" service "UploadThumbnail" endpoint
func (c *Client) BuildUploadThumbnailRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		filename string
		body     io.Reader
	)
	{
		rd, ok := v.(*videolearning.UploadThumbnailRequestData)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "UploadThumbnail", "videolearning.UploadThumbnailRequestData", v)
		}
		p := rd.Payload
		body = rd.Body
		filename = p.Filename
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UploadThumbnailVideoLearningPath(filename)}
	req, err := http.NewRequest("POST", u.String(), body)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "UploadThumbnail", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUploadThumbnailRequest returns an encoder for requests sent to the
// video_learning UploadThumbnail server.
func EncodeUploadThumbnailRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		data, ok := v.(*videolearning.UploadThumbnailRequestData)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "UploadThumbnail", "*videolearning.UploadThumbnailRequestData", v)
		}
		p := data.Payload
		{
			head := p.ContentType
			req.Header.Set("Content-Type", head)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeUploadThumbnailResponse returns a decoder for responses returned by
// the video_learning UploadThumbnail endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeUploadThumbnailResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "upload_failed" (type videolearning.UploadFailed): http.StatusInternalServerError
//   - error: internal error
func DecodeUploadThumbnailResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UploadThumbnailResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "UploadThumbnail", err)
			}
			err = ValidateUploadThumbnailResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "UploadThumbnail", err)
			}
			res := NewUploadThumbnailUploadResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "UploadThumbnail", err)
			}
			return nil, NewUploadThumbnailInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "UploadThumbnail", err)
				}
				return nil, NewUploadThumbnailInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "UploadThumbnail", err)
				}
				return nil, NewUploadThumbnailUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "UploadThumbnail", resp.StatusCode, string(body))
			}
		case http.StatusInternalServerError:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "UploadThumbnail", err)
			}
			return nil, NewUploadThumbnailUploadFailed(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "UploadThumbnail", resp.StatusCode, string(body))
		}
	}
}

// // BuildUploadThumbnailStreamPayload creates a streaming endpoint request
// payload from the method payload and the path to the file to be streamed
func BuildUploadThumbnailStreamPayload(payload any, fpath string) (*videolearning.UploadThumbnailRequestData, error) {
	f, err := os.Open(fpath)
	if err != nil {
		return nil, err
	}
	return &videolearning.UploadThumbnailRequestData{
		Payload: payload.(*videolearning.UploadThumbnailPayload),
		Body:    f,
	}, nil
}

// BuildGetAllCategoriesRequest instantiates a HTTP request object with method
// and path set to call the "video_learning" service "GetAllCategories" endpoint
func (c *Client) BuildGetAllCategoriesRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetAllCategoriesVideoLearningPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetAllCategories", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetAllCategoriesRequest returns an encoder for requests sent to the
// video_learning GetAllCategories server.
func EncodeGetAllCategoriesRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetAllCategoriesPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetAllCategories", "*videolearning.GetAllCategoriesPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeGetAllCategoriesResponse returns a decoder for responses returned by
// the video_learning GetAllCategories endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeGetAllCategoriesResponse may return the following errors:
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeGetAllCategoriesResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetAllCategoriesResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetAllCategories", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateVideoCategoryResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetAllCategories", err)
			}
			res := NewGetAllCategoriesVideoCategoryOK(body)
			return res, nil
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetAllCategories", err)
				}
				return nil, NewGetAllCategoriesInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetAllCategories", err)
				}
				return nil, NewGetAllCategoriesUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetAllCategories", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetAllCategories", resp.StatusCode, string(body))
		}
	}
}

// BuildGetAllTagsRequest instantiates a HTTP request object with method and
// path set to call the "video_learning" service "GetAllTags" endpoint
func (c *Client) BuildGetAllTagsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetAllTagsVideoLearningPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetAllTags", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetAllTagsRequest returns an encoder for requests sent to the
// video_learning GetAllTags server.
func EncodeGetAllTagsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetAllTagsPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetAllTags", "*videolearning.GetAllTagsPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeGetAllTagsResponse returns a decoder for responses returned by the
// video_learning GetAllTags endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetAllTagsResponse may return the following errors:
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeGetAllTagsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetAllTagsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetAllTags", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateVideoTagResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetAllTags", err)
			}
			res := NewGetAllTagsVideoTagOK(body)
			return res, nil
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetAllTags", err)
				}
				return nil, NewGetAllTagsInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetAllTags", err)
				}
				return nil, NewGetAllTagsUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetAllTags", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetAllTags", resp.StatusCode, string(body))
		}
	}
}

// BuildToggleVideoLikeRequest instantiates a HTTP request object with method
// and path set to call the "video_learning" service "ToggleVideoLike" endpoint
func (c *Client) BuildToggleVideoLikeRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		videoID int64
	)
	{
		p, ok := v.(*videolearning.ToggleVideoLikePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "ToggleVideoLike", "*videolearning.ToggleVideoLikePayload", v)
		}
		videoID = p.VideoID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ToggleVideoLikeVideoLearningPath(videoID)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "ToggleVideoLike", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeToggleVideoLikeRequest returns an encoder for requests sent to the
// video_learning ToggleVideoLike server.
func EncodeToggleVideoLikeRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.ToggleVideoLikePayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "ToggleVideoLike", "*videolearning.ToggleVideoLikePayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeToggleVideoLikeResponse returns a decoder for responses returned by
// the video_learning ToggleVideoLike endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeToggleVideoLikeResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "video_not_found" (type videolearning.VideoNotFound): http.StatusNotFound
//   - error: internal error
func DecodeToggleVideoLikeResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ToggleVideoLikeResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "ToggleVideoLike", err)
			}
			err = ValidateToggleVideoLikeResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "ToggleVideoLike", err)
			}
			res := NewToggleVideoLikeSimpleResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "ToggleVideoLike", err)
			}
			return nil, NewToggleVideoLikeInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "ToggleVideoLike", err)
				}
				return nil, NewToggleVideoLikeInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "ToggleVideoLike", err)
				}
				return nil, NewToggleVideoLikeUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "ToggleVideoLike", resp.StatusCode, string(body))
			}
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "ToggleVideoLike", err)
			}
			return nil, NewToggleVideoLikeVideoNotFound(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "ToggleVideoLike", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteVideoRequest instantiates a HTTP request object with method and
// path set to call the "video_learning" service "DeleteVideo" endpoint
func (c *Client) BuildDeleteVideoRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		videoID int64
	)
	{
		p, ok := v.(*videolearning.DeleteVideoPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "DeleteVideo", "*videolearning.DeleteVideoPayload", v)
		}
		videoID = p.VideoID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteVideoVideoLearningPath(videoID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "DeleteVideo", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteVideoRequest returns an encoder for requests sent to the
// video_learning DeleteVideo server.
func EncodeDeleteVideoRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.DeleteVideoPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "DeleteVideo", "*videolearning.DeleteVideoPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeDeleteVideoResponse returns a decoder for responses returned by the
// video_learning DeleteVideo endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeDeleteVideoResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "video_not_found" (type videolearning.VideoNotFound): http.StatusNotFound
//   - error: internal error
func DecodeDeleteVideoResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body DeleteVideoResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "DeleteVideo", err)
			}
			err = ValidateDeleteVideoResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "DeleteVideo", err)
			}
			res := NewDeleteVideoSimpleResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "DeleteVideo", err)
			}
			return nil, NewDeleteVideoInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "DeleteVideo", err)
				}
				return nil, NewDeleteVideoInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "DeleteVideo", err)
				}
				return nil, NewDeleteVideoUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "DeleteVideo", resp.StatusCode, string(body))
			}
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "DeleteVideo", err)
			}
			return nil, NewDeleteVideoVideoNotFound(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "DeleteVideo", resp.StatusCode, string(body))
		}
	}
}

// BuildGetVideosByCategoryRequest instantiates a HTTP request object with
// method and path set to call the "video_learning" service
// "GetVideosByCategory" endpoint
func (c *Client) BuildGetVideosByCategoryRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		categoryID int64
	)
	{
		p, ok := v.(*videolearning.GetVideosByCategoryPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "GetVideosByCategory", "*videolearning.GetVideosByCategoryPayload", v)
		}
		categoryID = p.CategoryID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetVideosByCategoryVideoLearningPath(categoryID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetVideosByCategory", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetVideosByCategoryRequest returns an encoder for requests sent to the
// video_learning GetVideosByCategory server.
func EncodeGetVideosByCategoryRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetVideosByCategoryPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetVideosByCategory", "*videolearning.GetVideosByCategoryPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		values := req.URL.Query()
		values.Add("amount", fmt.Sprintf("%v", p.Amount))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetVideosByCategoryResponse returns a decoder for responses returned
// by the video_learning GetVideosByCategory endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeGetVideosByCategoryResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeGetVideosByCategoryResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetVideosByCategoryResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetVideosByCategory", err)
			}
			err = ValidateGetVideosByCategoryResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetVideosByCategory", err)
			}
			res := NewGetVideosByCategoryVideoListOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetVideosByCategory", err)
			}
			return nil, NewGetVideosByCategoryInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetVideosByCategory", err)
				}
				return nil, NewGetVideosByCategoryInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetVideosByCategory", err)
				}
				return nil, NewGetVideosByCategoryUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetVideosByCategory", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetVideosByCategory", resp.StatusCode, string(body))
		}
	}
}

// BuildGetSimilarVideosRequest instantiates a HTTP request object with method
// and path set to call the "video_learning" service "GetSimilarVideos" endpoint
func (c *Client) BuildGetSimilarVideosRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		videoID int64
	)
	{
		p, ok := v.(*videolearning.GetSimilarVideosPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "GetSimilarVideos", "*videolearning.GetSimilarVideosPayload", v)
		}
		videoID = p.VideoID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetSimilarVideosVideoLearningPath(videoID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetSimilarVideos", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetSimilarVideosRequest returns an encoder for requests sent to the
// video_learning GetSimilarVideos server.
func EncodeGetSimilarVideosRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetSimilarVideosPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetSimilarVideos", "*videolearning.GetSimilarVideosPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		values := req.URL.Query()
		values.Add("amount", fmt.Sprintf("%v", p.Amount))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetSimilarVideosResponse returns a decoder for responses returned by
// the video_learning GetSimilarVideos endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeGetSimilarVideosResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "video_not_found" (type videolearning.VideoNotFound): http.StatusNotFound
//   - error: internal error
func DecodeGetSimilarVideosResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetSimilarVideosResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetSimilarVideos", err)
			}
			err = ValidateGetSimilarVideosResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetSimilarVideos", err)
			}
			res := NewGetSimilarVideosVideoListOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetSimilarVideos", err)
			}
			return nil, NewGetSimilarVideosInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetSimilarVideos", err)
				}
				return nil, NewGetSimilarVideosInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetSimilarVideos", err)
				}
				return nil, NewGetSimilarVideosUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetSimilarVideos", resp.StatusCode, string(body))
			}
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetSimilarVideos", err)
			}
			return nil, NewGetSimilarVideosVideoNotFound(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetSimilarVideos", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteCommentRequest instantiates a HTTP request object with method and
// path set to call the "video_learning" service "DeleteComment" endpoint
func (c *Client) BuildDeleteCommentRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		commentID int64
	)
	{
		p, ok := v.(*videolearning.DeleteCommentPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "DeleteComment", "*videolearning.DeleteCommentPayload", v)
		}
		commentID = p.CommentID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteCommentVideoLearningPath(commentID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "DeleteComment", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteCommentRequest returns an encoder for requests sent to the
// video_learning DeleteComment server.
func EncodeDeleteCommentRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.DeleteCommentPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "DeleteComment", "*videolearning.DeleteCommentPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeDeleteCommentResponse returns a decoder for responses returned by the
// video_learning DeleteComment endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeDeleteCommentResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "permission_denied" (type videolearning.PermissionDenied): http.StatusForbidden
//   - error: internal error
func DecodeDeleteCommentResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body DeleteCommentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "DeleteComment", err)
			}
			err = ValidateDeleteCommentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "DeleteComment", err)
			}
			res := NewDeleteCommentSimpleResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "DeleteComment", err)
			}
			return nil, NewDeleteCommentInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "DeleteComment", err)
				}
				return nil, NewDeleteCommentInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "DeleteComment", err)
				}
				return nil, NewDeleteCommentUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "DeleteComment", resp.StatusCode, string(body))
			}
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "DeleteComment", err)
			}
			return nil, NewDeleteCommentPermissionDenied(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "DeleteComment", resp.StatusCode, string(body))
		}
	}
}

// BuildGetOrCreateCategoryRequest instantiates a HTTP request object with
// method and path set to call the "video_learning" service
// "GetOrCreateCategory" endpoint
func (c *Client) BuildGetOrCreateCategoryRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetOrCreateCategoryVideoLearningPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetOrCreateCategory", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetOrCreateCategoryRequest returns an encoder for requests sent to the
// video_learning GetOrCreateCategory server.
func EncodeGetOrCreateCategoryRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetOrCreateCategoryPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetOrCreateCategory", "*videolearning.GetOrCreateCategoryPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		body := NewGetOrCreateCategoryRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("video_learning", "GetOrCreateCategory", err)
		}
		return nil
	}
}

// DecodeGetOrCreateCategoryResponse returns a decoder for responses returned
// by the video_learning GetOrCreateCategory endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeGetOrCreateCategoryResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeGetOrCreateCategoryResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body GetOrCreateCategoryResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetOrCreateCategory", err)
			}
			err = ValidateGetOrCreateCategoryResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetOrCreateCategory", err)
			}
			res := NewGetOrCreateCategoryVideoCategoryCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetOrCreateCategory", err)
			}
			return nil, NewGetOrCreateCategoryInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetOrCreateCategory", err)
				}
				return nil, NewGetOrCreateCategoryInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetOrCreateCategory", err)
				}
				return nil, NewGetOrCreateCategoryUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetOrCreateCategory", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetOrCreateCategory", resp.StatusCode, string(body))
		}
	}
}

// BuildGetCategoryByIDRequest instantiates a HTTP request object with method
// and path set to call the "video_learning" service "GetCategoryById" endpoint
func (c *Client) BuildGetCategoryByIDRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		categoryID int64
	)
	{
		p, ok := v.(*videolearning.GetCategoryByIDPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "GetCategoryById", "*videolearning.GetCategoryByIDPayload", v)
		}
		categoryID = p.CategoryID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetCategoryByIDVideoLearningPath(categoryID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetCategoryById", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetCategoryByIDRequest returns an encoder for requests sent to the
// video_learning GetCategoryById server.
func EncodeGetCategoryByIDRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetCategoryByIDPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetCategoryById", "*videolearning.GetCategoryByIDPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeGetCategoryByIDResponse returns a decoder for responses returned by
// the video_learning GetCategoryById endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeGetCategoryByIDResponse may return the following errors:
//   - "category_not_found" (type videolearning.CategoryNotFound): http.StatusNotFound
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeGetCategoryByIDResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetCategoryByIDResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetCategoryById", err)
			}
			err = ValidateGetCategoryByIDResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetCategoryById", err)
			}
			res := NewGetCategoryByIDVideoCategoryOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetCategoryById", err)
			}
			return nil, NewGetCategoryByIDCategoryNotFound(body)
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetCategoryById", err)
			}
			return nil, NewGetCategoryByIDInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetCategoryById", err)
				}
				return nil, NewGetCategoryByIDInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetCategoryById", err)
				}
				return nil, NewGetCategoryByIDUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetCategoryById", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetCategoryById", resp.StatusCode, string(body))
		}
	}
}

// BuildGetOrCreateTagRequest instantiates a HTTP request object with method
// and path set to call the "video_learning" service "GetOrCreateTag" endpoint
func (c *Client) BuildGetOrCreateTagRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetOrCreateTagVideoLearningPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetOrCreateTag", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetOrCreateTagRequest returns an encoder for requests sent to the
// video_learning GetOrCreateTag server.
func EncodeGetOrCreateTagRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetOrCreateTagPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetOrCreateTag", "*videolearning.GetOrCreateTagPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		body := NewGetOrCreateTagRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("video_learning", "GetOrCreateTag", err)
		}
		return nil
	}
}

// DecodeGetOrCreateTagResponse returns a decoder for responses returned by the
// video_learning GetOrCreateTag endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetOrCreateTagResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeGetOrCreateTagResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body GetOrCreateTagResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetOrCreateTag", err)
			}
			err = ValidateGetOrCreateTagResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetOrCreateTag", err)
			}
			res := NewGetOrCreateTagVideoTagCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetOrCreateTag", err)
			}
			return nil, NewGetOrCreateTagInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetOrCreateTag", err)
				}
				return nil, NewGetOrCreateTagInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetOrCreateTag", err)
				}
				return nil, NewGetOrCreateTagUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetOrCreateTag", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetOrCreateTag", resp.StatusCode, string(body))
		}
	}
}

// BuildGetTagByIDRequest instantiates a HTTP request object with method and
// path set to call the "video_learning" service "GetTagById" endpoint
func (c *Client) BuildGetTagByIDRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		tagID int64
	)
	{
		p, ok := v.(*videolearning.GetTagByIDPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("video_learning", "GetTagById", "*videolearning.GetTagByIDPayload", v)
		}
		tagID = p.TagID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetTagByIDVideoLearningPath(tagID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("video_learning", "GetTagById", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetTagByIDRequest returns an encoder for requests sent to the
// video_learning GetTagById server.
func EncodeGetTagByIDRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*videolearning.GetTagByIDPayload)
		if !ok {
			return goahttp.ErrInvalidType("video_learning", "GetTagById", "*videolearning.GetTagByIDPayload", v)
		}
		{
			v := p.SessionToken
			req.AddCookie(&http.Cookie{
				Name:  "session",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeGetTagByIDResponse returns a decoder for responses returned by the
// video_learning GetTagById endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetTagByIDResponse may return the following errors:
//   - "invalid_input" (type videolearning.InvalidInput): http.StatusBadRequest
//   - "invalid_session" (type videolearning.InvalidSession): http.StatusUnauthorized
//   - "unauthorized" (type videolearning.Unauthorized): http.StatusUnauthorized
//   - "tag_not_found" (type videolearning.TagNotFound): http.StatusNotFound
//   - error: internal error
func DecodeGetTagByIDResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetTagByIDResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetTagById", err)
			}
			err = ValidateGetTagByIDResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("video_learning", "GetTagById", err)
			}
			res := NewGetTagByIDVideoTagOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetTagById", err)
			}
			return nil, NewGetTagByIDInvalidInput(body)
		case http.StatusUnauthorized:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_session":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetTagById", err)
				}
				return nil, NewGetTagByIDInvalidSession(body)
			case "unauthorized":
				var (
					body string
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("video_learning", "GetTagById", err)
				}
				return nil, NewGetTagByIDUnauthorized(body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("video_learning", "GetTagById", resp.StatusCode, string(body))
			}
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("video_learning", "GetTagById", err)
			}
			return nil, NewGetTagByIDTagNotFound(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("video_learning", "GetTagById", resp.StatusCode, string(body))
		}
	}
}

// unmarshalVideoResponseBodyToVideolearningVideo builds a value of type
// *videolearning.Video from a value of type *VideoResponseBody.
func unmarshalVideoResponseBodyToVideolearningVideo(v *VideoResponseBody) *videolearning.Video {
	res := &videolearning.Video{
		ID:           *v.ID,
		Title:        *v.Title,
		Author:       *v.Author,
		Views:        *v.Views,
		Likes:        *v.Likes,
		ThumbnailURL: *v.ThumbnailURL,
	}

	return res
}

// unmarshalCommentResponseBodyToVideolearningComment builds a value of type
// *videolearning.Comment from a value of type *CommentResponseBody.
func unmarshalCommentResponseBodyToVideolearningComment(v *CommentResponseBody) *videolearning.Comment {
	res := &videolearning.Comment{
		ID:      *v.ID,
		Author:  *v.Author,
		Date:    *v.Date,
		Title:   *v.Title,
		Body:    *v.Body,
		VideoID: *v.VideoID,
	}

	return res
}

// unmarshalOwnVideoResponseToVideolearningOwnVideo builds a value of type
// *videolearning.OwnVideo from a value of type *OwnVideoResponse.
func unmarshalOwnVideoResponseToVideolearningOwnVideo(v *OwnVideoResponse) *videolearning.OwnVideo {
	res := &videolearning.OwnVideo{
		ID:           *v.ID,
		Title:        *v.Title,
		Views:        *v.Views,
		Likes:        *v.Likes,
		ThumbnailURL: *v.ThumbnailURL,
		UploadDate:   *v.UploadDate,
	}

	return res
}

// unmarshalVideoCategoryResponseToVideolearningVideoCategory builds a value of
// type *videolearning.VideoCategory from a value of type
// *VideoCategoryResponse.
func unmarshalVideoCategoryResponseToVideolearningVideoCategory(v *VideoCategoryResponse) *videolearning.VideoCategory {
	res := &videolearning.VideoCategory{
		ID:   *v.ID,
		Name: *v.Name,
	}

	return res
}

// unmarshalVideoTagResponseToVideolearningVideoTag builds a value of type
// *videolearning.VideoTag from a value of type *VideoTagResponse.
func unmarshalVideoTagResponseToVideolearningVideoTag(v *VideoTagResponse) *videolearning.VideoTag {
	res := &videolearning.VideoTag{
		ID:   *v.ID,
		Name: *v.Name,
	}

	return res
}
