// Code generated by goa v3.21.1, DO NOT EDIT.
//
// codelab HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/ynoacamino/infra-sustainable-classrooms/services/codelab/design/api
// -o ./services/codelab/

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	codelab "github.com/ynoacamino/infra-sustainable-classrooms/services/codelab/gen/codelab"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateExercisePayload builds the payload for the codelab CreateExercise
// endpoint from CLI flags.
func BuildCreateExercisePayload(codelabCreateExerciseBody string, codelabCreateExerciseSessionToken string) (*codelab.CreateExercisePayload, error) {
	var err error
	var body CreateExerciseRequestBody
	{
		err = json.Unmarshal([]byte(codelabCreateExerciseBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"created_by\": 123,\n      \"description\": \"Write a function that returns the sum of two numbers\",\n      \"difficulty\": \"easy\",\n      \"initial_code\": \"def sum_two_numbers(a, b):\\n    # Write your code here\\n    pass\",\n      \"solution\": \"def sum_two_numbers(a, b):\\n    return a + b\",\n      \"title\": \"Sum Two Numbers\"\n   }'")
		}
		if utf8.RuneCountInString(body.Title) > 200 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 200, false))
		}
		if !(body.Difficulty == "easy" || body.Difficulty == "medium" || body.Difficulty == "hard") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.difficulty", body.Difficulty, []any{"easy", "medium", "hard"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken string
	{
		sessionToken = codelabCreateExerciseSessionToken
	}
	v := &codelab.CreateExercisePayload{
		Title:       body.Title,
		Description: body.Description,
		InitialCode: body.InitialCode,
		Solution:    body.Solution,
		Difficulty:  body.Difficulty,
		CreatedBy:   body.CreatedBy,
	}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetExercisePayload builds the payload for the codelab GetExercise
// endpoint from CLI flags.
func BuildGetExercisePayload(codelabGetExerciseID string, codelabGetExerciseSessionToken string) (*codelab.GetExercisePayload, error) {
	var err error
	var id int64
	{
		id, err = strconv.ParseInt(codelabGetExerciseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabGetExerciseSessionToken
	}
	v := &codelab.GetExercisePayload{}
	v.ID = id
	v.SessionToken = sessionToken

	return v, nil
}

// BuildListExercisesPayload builds the payload for the codelab ListExercises
// endpoint from CLI flags.
func BuildListExercisesPayload(codelabListExercisesSessionToken string) (*codelab.ListExercisesPayload, error) {
	var sessionToken string
	{
		sessionToken = codelabListExercisesSessionToken
	}
	v := &codelab.ListExercisesPayload{}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildUpdateExercisePayload builds the payload for the codelab UpdateExercise
// endpoint from CLI flags.
func BuildUpdateExercisePayload(codelabUpdateExerciseBody string, codelabUpdateExerciseID string, codelabUpdateExerciseSessionToken string) (*codelab.UpdateExercisePayload2, error) {
	var err error
	var body UpdateExerciseRequestBody
	{
		err = json.Unmarshal([]byte(codelabUpdateExerciseBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"exercise\": {\n         \"description\": \"Write a function that returns the sum of two numbers\",\n         \"difficulty\": \"easy\",\n         \"initial_code\": \"def sum_two_numbers(a, b):\\n    # Write your code here\\n    pass\",\n         \"solution\": \"def sum_two_numbers(a, b):\\n    return a + b\",\n         \"title\": \"Sum Two Numbers\"\n      }\n   }'")
		}
		if body.Exercise == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("exercise", "body"))
		}
		if body.Exercise != nil {
			if err2 := ValidateUpdateExercisePayloadRequestBody(body.Exercise); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var id int64
	{
		id, err = strconv.ParseInt(codelabUpdateExerciseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabUpdateExerciseSessionToken
	}
	v := &codelab.UpdateExercisePayload2{}
	if body.Exercise != nil {
		v.Exercise = marshalUpdateExercisePayloadRequestBodyToCodelabUpdateExercisePayload(body.Exercise)
	}
	v.ID = id
	v.SessionToken = sessionToken

	return v, nil
}

// BuildDeleteExercisePayload builds the payload for the codelab DeleteExercise
// endpoint from CLI flags.
func BuildDeleteExercisePayload(codelabDeleteExerciseID string, codelabDeleteExerciseSessionToken string) (*codelab.DeleteExercisePayload, error) {
	var err error
	var id int64
	{
		id, err = strconv.ParseInt(codelabDeleteExerciseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabDeleteExerciseSessionToken
	}
	v := &codelab.DeleteExercisePayload{}
	v.ID = id
	v.SessionToken = sessionToken

	return v, nil
}

// BuildCreateTestPayload builds the payload for the codelab CreateTest
// endpoint from CLI flags.
func BuildCreateTestPayload(codelabCreateTestBody string, codelabCreateTestSessionToken string) (*codelab.CreateTestPayload, error) {
	var err error
	var body CreateTestRequestBody
	{
		err = json.Unmarshal([]byte(codelabCreateTestBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"exercise_id\": 1,\n      \"input\": \"5, 3\",\n      \"output\": \"8\",\n      \"public\": true\n   }'")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabCreateTestSessionToken
	}
	v := &codelab.CreateTestPayload{
		Input:      body.Input,
		Output:     body.Output,
		Public:     body.Public,
		ExerciseID: body.ExerciseID,
	}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetTestsByExercisePayload builds the payload for the codelab
// GetTestsByExercise endpoint from CLI flags.
func BuildGetTestsByExercisePayload(codelabGetTestsByExerciseExerciseID string, codelabGetTestsByExerciseSessionToken string) (*codelab.GetTestsByExercisePayload, error) {
	var err error
	var exerciseID int64
	{
		exerciseID, err = strconv.ParseInt(codelabGetTestsByExerciseExerciseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for exerciseID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabGetTestsByExerciseSessionToken
	}
	v := &codelab.GetTestsByExercisePayload{}
	v.ExerciseID = exerciseID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildUpdateTestPayload builds the payload for the codelab UpdateTest
// endpoint from CLI flags.
func BuildUpdateTestPayload(codelabUpdateTestBody string, codelabUpdateTestID string, codelabUpdateTestSessionToken string) (*codelab.UpdateTestPayload2, error) {
	var err error
	var body UpdateTestRequestBody
	{
		err = json.Unmarshal([]byte(codelabUpdateTestBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"test\": {\n         \"input\": \"5, 3\",\n         \"output\": \"8\",\n         \"public\": true\n      }\n   }'")
		}
		if body.Test == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("test", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var id int64
	{
		id, err = strconv.ParseInt(codelabUpdateTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabUpdateTestSessionToken
	}
	v := &codelab.UpdateTestPayload2{}
	if body.Test != nil {
		v.Test = marshalUpdateTestPayloadRequestBodyToCodelabUpdateTestPayload(body.Test)
	}
	v.ID = id
	v.SessionToken = sessionToken

	return v, nil
}

// BuildDeleteTestPayload builds the payload for the codelab DeleteTest
// endpoint from CLI flags.
func BuildDeleteTestPayload(codelabDeleteTestID string, codelabDeleteTestSessionToken string) (*codelab.DeleteTestPayload, error) {
	var err error
	var id int64
	{
		id, err = strconv.ParseInt(codelabDeleteTestID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabDeleteTestSessionToken
	}
	v := &codelab.DeleteTestPayload{}
	v.ID = id
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetExerciseForStudentPayload builds the payload for the codelab
// GetExerciseForStudent endpoint from CLI flags.
func BuildGetExerciseForStudentPayload(codelabGetExerciseForStudentID string, codelabGetExerciseForStudentSessionToken string) (*codelab.GetExerciseForStudentPayload, error) {
	var err error
	var id int64
	{
		id, err = strconv.ParseInt(codelabGetExerciseForStudentID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabGetExerciseForStudentSessionToken
	}
	v := &codelab.GetExerciseForStudentPayload{}
	v.ID = id
	v.SessionToken = sessionToken

	return v, nil
}

// BuildListExercisesForStudentsPayload builds the payload for the codelab
// ListExercisesForStudents endpoint from CLI flags.
func BuildListExercisesForStudentsPayload(codelabListExercisesForStudentsSessionToken string) (*codelab.ListExercisesForStudentsPayload, error) {
	var sessionToken string
	{
		sessionToken = codelabListExercisesForStudentsSessionToken
	}
	v := &codelab.ListExercisesForStudentsPayload{}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildCreateAttemptPayload builds the payload for the codelab CreateAttempt
// endpoint from CLI flags.
func BuildCreateAttemptPayload(codelabCreateAttemptBody string, codelabCreateAttemptSessionToken string) (*codelab.CreateAttemptPayload, error) {
	var err error
	var body CreateAttemptRequestBody
	{
		err = json.Unmarshal([]byte(codelabCreateAttemptBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"code\": \"def sum_two_numbers(a, b):\\n    return a + b\",\n      \"exercise_id\": 1,\n      \"success\": true\n   }'")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabCreateAttemptSessionToken
	}
	v := &codelab.CreateAttemptPayload{
		ExerciseID: body.ExerciseID,
		Code:       body.Code,
		Success:    body.Success,
	}
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetAttemptsByUserAndExercisePayload builds the payload for the codelab
// GetAttemptsByUserAndExercise endpoint from CLI flags.
func BuildGetAttemptsByUserAndExercisePayload(codelabGetAttemptsByUserAndExerciseUserID string, codelabGetAttemptsByUserAndExerciseExerciseID string, codelabGetAttemptsByUserAndExerciseSessionToken string) (*codelab.GetAttemptsByUserAndExercisePayload, error) {
	var err error
	var userID int64
	{
		userID, err = strconv.ParseInt(codelabGetAttemptsByUserAndExerciseUserID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for userID, must be INT64")
		}
	}
	var exerciseID int64
	{
		exerciseID, err = strconv.ParseInt(codelabGetAttemptsByUserAndExerciseExerciseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for exerciseID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabGetAttemptsByUserAndExerciseSessionToken
	}
	v := &codelab.GetAttemptsByUserAndExercisePayload{}
	v.UserID = userID
	v.ExerciseID = exerciseID
	v.SessionToken = sessionToken

	return v, nil
}

// BuildGetAnswerByUserAndExercisePayload builds the payload for the codelab
// GetAnswerByUserAndExercise endpoint from CLI flags.
func BuildGetAnswerByUserAndExercisePayload(codelabGetAnswerByUserAndExerciseUserID string, codelabGetAnswerByUserAndExerciseExerciseID string, codelabGetAnswerByUserAndExerciseSessionToken string) (*codelab.GetAnswerByUserAndExercisePayload, error) {
	var err error
	var userID int64
	{
		userID, err = strconv.ParseInt(codelabGetAnswerByUserAndExerciseUserID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for userID, must be INT64")
		}
	}
	var exerciseID int64
	{
		exerciseID, err = strconv.ParseInt(codelabGetAnswerByUserAndExerciseExerciseID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for exerciseID, must be INT64")
		}
	}
	var sessionToken string
	{
		sessionToken = codelabGetAnswerByUserAndExerciseSessionToken
	}
	v := &codelab.GetAnswerByUserAndExercisePayload{}
	v.UserID = userID
	v.ExerciseID = exerciseID
	v.SessionToken = sessionToken

	return v, nil
}
