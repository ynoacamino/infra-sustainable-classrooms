// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: attempts.sql

package codelabdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAttemptsByAnswer = `-- name: CountAttemptsByAnswer :one
SELECT COUNT(*) FROM attempts 
WHERE answer_id = $1
`

func (q *Queries) CountAttemptsByAnswer(ctx context.Context, answerID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countAttemptsByAnswer, answerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSuccessfulAttemptsByAnswer = `-- name: CountSuccessfulAttemptsByAnswer :one
SELECT COUNT(*) FROM attempts 
WHERE answer_id = $1 AND success = true
`

func (q *Queries) CountSuccessfulAttemptsByAnswer(ctx context.Context, answerID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countSuccessfulAttemptsByAnswer, answerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSuccessfulAttemptsByExercise = `-- name: CountSuccessfulAttemptsByExercise :one
SELECT COUNT(a.*) FROM attempts a
JOIN answers ans ON a.answer_id = ans.id
WHERE ans.exercise_id = $1 AND a.success = true
`

func (q *Queries) CountSuccessfulAttemptsByExercise(ctx context.Context, exerciseID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countSuccessfulAttemptsByExercise, exerciseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTotalAttemptsByExercise = `-- name: CountTotalAttemptsByExercise :one
SELECT COUNT(a.*) FROM attempts a
JOIN answers ans ON a.answer_id = ans.id
WHERE ans.exercise_id = $1
`

func (q *Queries) CountTotalAttemptsByExercise(ctx context.Context, exerciseID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countTotalAttemptsByExercise, exerciseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttempt = `-- name: CreateAttempt :exec
INSERT INTO attempts (answer_id, code, success)
VALUES ($1, $2, $3)
`

type CreateAttemptParams struct {
	AnswerID int64
	Code     string
	Success  bool
}

func (q *Queries) CreateAttempt(ctx context.Context, arg CreateAttemptParams) error {
	_, err := q.db.Exec(ctx, createAttempt, arg.AnswerID, arg.Code, arg.Success)
	return err
}

const getAttempt = `-- name: GetAttempt :one
SELECT id, answer_id, code, success, created_at FROM attempts WHERE id = $1
`

func (q *Queries) GetAttempt(ctx context.Context, id int64) (Attempt, error) {
	row := q.db.QueryRow(ctx, getAttempt, id)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.AnswerID,
		&i.Code,
		&i.Success,
		&i.CreatedAt,
	)
	return i, err
}

const getAttemptsByAnswer = `-- name: GetAttemptsByAnswer :many
SELECT id, answer_id, code, success, created_at FROM attempts 
WHERE answer_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetAttemptsByAnswer(ctx context.Context, answerID int64) ([]Attempt, error) {
	rows, err := q.db.Query(ctx, getAttemptsByAnswer, answerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attempt
	for rows.Next() {
		var i Attempt
		if err := rows.Scan(
			&i.ID,
			&i.AnswerID,
			&i.Code,
			&i.Success,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttemptsByUserAndExercise = `-- name: GetAttemptsByUserAndExercise :many
SELECT a.id, a.answer_id, a.code, a.success, a.created_at FROM attempts a
JOIN answers ans ON a.answer_id = ans.id
WHERE ans.user_id = $1 AND ans.exercise_id = $2
ORDER BY a.created_at DESC
`

type GetAttemptsByUserAndExerciseParams struct {
	UserID     int64
	ExerciseID int64
}

func (q *Queries) GetAttemptsByUserAndExercise(ctx context.Context, arg GetAttemptsByUserAndExerciseParams) ([]Attempt, error) {
	rows, err := q.db.Query(ctx, getAttemptsByUserAndExercise, arg.UserID, arg.ExerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attempt
	for rows.Next() {
		var i Attempt
		if err := rows.Scan(
			&i.ID,
			&i.AnswerID,
			&i.Code,
			&i.Success,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttemptsWithAnswerInfo = `-- name: GetAttemptsWithAnswerInfo :many
SELECT 
    a.id,
    a.answer_id,
    a.code,
    a.success,
    a.created_at,
    ans.user_id,
    ans.exercise_id,
    ans.completed as answer_completed
FROM attempts a
JOIN answers ans ON a.answer_id = ans.id
WHERE ans.exercise_id = $1
ORDER BY a.created_at DESC
`

type GetAttemptsWithAnswerInfoRow struct {
	ID              int64
	AnswerID        int64
	Code            string
	Success         bool
	CreatedAt       pgtype.Timestamptz
	UserID          int64
	ExerciseID      int64
	AnswerCompleted bool
}

func (q *Queries) GetAttemptsWithAnswerInfo(ctx context.Context, exerciseID int64) ([]GetAttemptsWithAnswerInfoRow, error) {
	rows, err := q.db.Query(ctx, getAttemptsWithAnswerInfo, exerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAttemptsWithAnswerInfoRow
	for rows.Next() {
		var i GetAttemptsWithAnswerInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.AnswerID,
			&i.Code,
			&i.Success,
			&i.CreatedAt,
			&i.UserID,
			&i.ExerciseID,
			&i.AnswerCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestAttemptByAnswer = `-- name: GetLatestAttemptByAnswer :one
SELECT id, answer_id, code, success, created_at FROM attempts 
WHERE answer_id = $1 
ORDER BY created_at DESC 
LIMIT 1
`

func (q *Queries) GetLatestAttemptByAnswer(ctx context.Context, answerID int64) (Attempt, error) {
	row := q.db.QueryRow(ctx, getLatestAttemptByAnswer, answerID)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.AnswerID,
		&i.Code,
		&i.Success,
		&i.CreatedAt,
	)
	return i, err
}

const getUserAttemptsForExercise = `-- name: GetUserAttemptsForExercise :many
SELECT 
    a.id,
    a.answer_id,
    a.code,
    a.success,
    a.created_at
FROM attempts a
JOIN answers ans ON a.answer_id = ans.id
WHERE ans.user_id = $1 AND ans.exercise_id = $2
ORDER BY a.created_at DESC
`

type GetUserAttemptsForExerciseParams struct {
	UserID     int64
	ExerciseID int64
}

func (q *Queries) GetUserAttemptsForExercise(ctx context.Context, arg GetUserAttemptsForExerciseParams) ([]Attempt, error) {
	rows, err := q.db.Query(ctx, getUserAttemptsForExercise, arg.UserID, arg.ExerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attempt
	for rows.Next() {
		var i Attempt
		if err := rows.Scan(
			&i.ID,
			&i.AnswerID,
			&i.Code,
			&i.Success,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
